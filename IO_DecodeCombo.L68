00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 05/31/20 7:19:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Scott Shirley, Carl Howing
00000000                             4  * Date       : June 6, 2020
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00000000                             7  *Register Use
00000000                             8  *For consistency, please utilize registers in the following way.
00000000                             9  *
00000000                            10  *D0 -
00000000                            11  *D1 -
00000000                            12  *D2 - copy of working address
00000000                            13  *D3 - utility register
00000000                            14  *D4 -
00000000                            15  *D5 - flag condition
00000000                            16  *D6 - counter
00000000                            17  *D7 -
00000000                            18  *
00000000                            19  *A0 - temp address holder
00000000                            20  *A1 - trap address
00000000                            21  *A2 - buffer address of decoded instruction
00000000                            22  *A3 -
00000000                            23  *A4 - starting address
00000000                            24  *A5 - ending address
00000000                            25  *A6 -
00000000                            26  *A7 -
00000000                            27  *-----------------------------------------------------------
00000000                            28  
00000000                            29  *-----------------------------------------------------------
00000000                            30  * Variables and EQUs
00000000                            31  *-----------------------------------------------------------
00000000  =00001000                 32  start       EQU     $1000               *start address
00000000  =0000A000                 33  stack       EQU     $A000               *stack address  
00000000                            34   
00000000                            35  
00000000  =00000000                 36  minAdd      EQU     $00000000           *start of address space
00000000  =00FFFFFF                 37  maxAdd      EQU     $00FFFFFF           *end of address space
00000000                            38  
00000000  =0000000D                 39  CR          EQU     $0D                 *carriage return
00000000  =0000000A                 40  LF          EQU     $0A                 *line feed
00000000                            41  
00000000  =00000001                 42  goodflag    EQU     1                   *good flag condition
00000000  =00000000                 43  badflag     EQU     0                   *bad flag condition
00000000  =00000000                 44  length      EQU     0                   *
00000000                            45  
00000000  =0000000A                 46  printCount  EQU     10                  *number of lines printed to console before user input
00000000                            47  
00000000                            48  *TRAP tasks for preload
00000000  =00000000                 49  task0       EQU     00                  *Display string at (A1), D1.W bytes long (max 255) with carriage return and line feed (CR, LF)
00000000  =00000001                 50  task1       EQU     01                  *Display string at (A1), D1.W bytes long (max 255) without CR, LF
00000000  =00000002                 51  task2       EQU     02                  *Read string from keyboard and store at (A1), NULL terminated, length retuned in D1.W (max 80)
00000000  =00000003                 52  task3       EQU     03                  *Display signed number in D1.L in decimal in smallest field
00000000  =0000000D                 53  task13      EQU     13                  *Display the NULL terminated string at (A1) with CR, LF
00000000  =0000000E                 54  task14      EQU     14                  *Display the NULL terminated string at (A1) without CR, LF
00000000                            55  
00000000                            56  *-----------------------------------------------------------
00000000                            57  *beging program
00000000                            58  *-----------------------------------------------------------
00001000                            59              ORG     start
00001000  6100 0048                 60              BSR     dis_intro_msg       *print intro message
00001004                            61              
00001004  6100 00E0                 62  main        BSR     CLEAR               *clear all registers
00001008  4FF9 0000A000             63              LEA     stack, SP           *load stack pointer
0000100E  45F9 0000136E             64              LEA     buffer, A2          *set buffer for input
00001014  2C4A                      65              MOVEA.L A2,A6 
00001016                            66              
00001016                            67              
00001016  6100 00E0                 68  main_input  BSR     U_INPUT             *branch to input
0000101A  BA3C 0000                 69              CMP.B   #$0, D5             *check if bad input
0000101E  6700 003E                 70              BEQ     dis_badInput        *bad flag, reinput 
00001022                            71              
00001022                            72              
00001022  4EB9 000010AC             73  main_test   JSR     dis_test            *display inputs
00001028                            74  
00001028                            75              
00001028  4EB9 00001204             76  main_loop   JSR     BUFFER_PREP         *prep buffer
0000102E                            77  
0000102E                            78  *loop checking      
0000102E  BBC8                      79              CMPA.L  A0, A5              * have we reached the end of our address range?
00001030  6F00 0014                 80              BLE     main_end  
00001034                            81   
00001034  5246                      82              ADDI    #1, D6              *add counter
00001036  BC7C 000A                 83              CMP     #printcount, D6     *check loop progress
0000103A  66EC                      84              BNE     main_loop
0000103C                            85                
0000103C                            86              
0000103C                            87  
0000103C  4EB9 0000108C             88  main_cont   JSR     dis_cont
00001042  4EF8 1028                 89              JMP     main_loop
00001046                            90  
00001046                            91  
00001046                            92  
00001046  6100 0252                 93  main_end    BSR     END
0000104A                            94  
0000104A                            95  *-----------------------------------------------------------
0000104A                            96  *display subroutines
0000104A                            97  *intro message, bad inputs, carriage return, enter2return, input test
0000104A                            98  *-----------------------------------------------------------
0000104A                            99  *intro message display
0000104A                           100  ************************************************************
0000104A                           101  dis_intro_msg
0000104A  103C 000D                102              MOVE.B  #13,D0              *load task
0000104E  43F9 0000129E            103              LEA     intro,A1            *load string
00001054  3239 000012B6            104              MOVE.W  i_length,D1         *load string length 
0000105A  4E4F                     105              TRAP    #15                 *display
0000105C  4E75                     106  endIntro    RTS                         *return
0000105E                           107  
0000105E                           108  *bad input error message display
0000105E                           109  ************************************************************
0000105E                           110  dis_badInput
0000105E  103C 0000                111              MOVE.B  #task0,D0           *load task
00001062  43F9 00001320            112              LEA     str_error, A1       *load string
00001068  3239 0000134C            113              MOVE.W  err_len, D1         *load string length
0000106E  4E4F                     114              TRAP    #15                 *display
00001070  1A3C 0000                115              MOVE.B  #badFlag,D5         *set flag condition to bad
00001074  4EB8 1016                116  endBI       JSR     main_input          *return to main_input
00001078                           117  
00001078                           118  *dsiplay carriage return
00001078                           119  ************************************************************
00001078                           120  dis_cr
00001078  103C 000D                121              MOVE.B  #task13, D0         *load task
0000107C  43F9 0000136A            122              LEA     str_cr, A1          *load string
00001082  3239 0000136C            123              MOVE.W  cr_len, D1          *load string length
00001088  4E4F                     124              TRAP    #15                 *display
0000108A  4E75                     125  end_cr      RTS                         *return
0000108C                           126  
0000108C                           127  *enter2return
0000108C                           128  ************************************************************
0000108C                           129  dis_cont   
0000108C  103C 000E                130              MOVE.B  #task14, D0         *load task
00001090  43F9 0000134E            131              LEA     str_cont, A1        *load string
00001096  3239 00001368            132              MOVE.W  cont_len, D1        *load string length
0000109C  4E4F                     133              TRAP    #15                 *display
0000109E                           134              
0000109E  103C 0002                135              MOVE.B  #task2,D0           *load task
000010A2  4E4F                     136              TRAP    #15                 *get input
000010A4                           137              
000010A4  12BC 0050                138              MOVE.B  #$50,(A1)           *reset A1
000010A8                           139              
000010A8  4246                     140              CLR     D6                  *clear counter, reset loop
000010AA  4E75                     141  endDC       RTS                         *return
000010AC                           142  
000010AC                           143  
000010AC                           144  *dsiplay input test
000010AC                           145  ************************************************************ 
000010AC                           146  dis_test     
000010AC  103C 000E                147              MOVE.B  #task14, D0         *
000010B0  43F9 000012EE            148              LEA     t_str_start, A1     *print start add test message     
000010B6  4E4F                     149              TRAP    #15                 *
000010B8                           150              
000010B8  2239 00001378            151              MOVE.L  v_srt_add, D1       *
000010BE  103C 0003                152              MOVE.B  #task3, D0          *print start add test value
000010C2  4E4F                     153              TRAP    #15                 *
000010C4                           154              
000010C4  4EB8 1078                155              JSR     dis_cr
000010C8                           156         
000010C8  103C 000E                157              MOVE.B  #task14, D0         *print end add test message
000010CC  43F9 00001308            158              LEA     t_str_end, A1         *    
000010D2  4E4F                     159              TRAP    #15                 *
000010D4                           160    
000010D4  2239 0000137C            161              MOVE.L  v_end_add, D1       *
000010DA  103C 0003                162              MOVE.B  #task3, D0          *print end add test value
000010DE  4E4F                     163              TRAP    #15                 *
000010E0                           164              
000010E0  4EB8 1078                165              JSR     dis_cr
000010E4  4E75                     166  endT        RTS
000010E6                           167  
000010E6                           168  
000010E6                           169  *-----------------------------------------------------------
000010E6                           170  *helper subroutines
000010E6                           171  *----------------------------------------------------------- 
000010E6                           172  
000010E6                           173  ************************************************************   
000010E6                           174  *CLEAR
000010E6                           175  *Description: Clears registers of values
000010E6                           176  ************************************************************        
000010E6                           177  CLEAR:
000010E6  4240                     178              CLR     D0
000010E8  4241                     179              CLR     D1
000010EA  4242                     180              CLR     D2
000010EC  4243                     181              CLR     D3
000010EE  4244                     182              CLR     D4
000010F0  4245                     183              CLR     D5
000010F2  4246                     184              CLR     D6
000010F4  4247                     185              CLR     D7
000010F6  4E75                     186  endClear    RTS
000010F8                           187  
000010F8                           188  ************************************************************
000010F8                           189  *U_INPUT
000010F8                           190  *Description: Gets input address from user for program
000010F8                           191  *D5 - Return Status
000010F8                           192  *D7 - Temparary register to store address value
000010F8                           193  *A0 - Working Address
000010F8                           194  *A4 - Start Address
000010F8                           195  *A5 - End Address
000010F8                           196  ************************************************************
000010F8                           197  U_INPUT:
000010F8  103C 0001                198              MOVE.B  #task1,D0           *
000010FC  43F9 000012B8            199              LEA     srt_addr,A1         *
00001102  3239 000012D2            200              MOVE.W  s_len,D1            *
00001108  4E4F                     201              TRAP    #15                 *
0000110A  D3FC 000012D2            202              ADDA.L  #s_len,A1           *
00001110  103C 0002                203              MOVE.B  #task2,D0           *
00001114  4E4F                     204              TRAP    #15                 *
00001116  4EB9 00001168            205              JSR     ASCII2HEX
0000111C  BA3C 0000                206              CMP.B   #$00,D5             *bad input?
00001120  6700 0044                207              BEQ     endInput
00001124  23C7 00001378            208              MOVE.L  D7, v_srt_add       *store to varable
0000112A  4247                     209              CLR     D7
0000112C                           210              
0000112C  2848                     211              MOVEA.L A0,A4       
0000112E  103C 0001                212              MOVE.B  #task1,D0
00001132  43F9 000012D4            213              LEA     end_addr,A1
00001138  3239 000012EC            214              MOVE.W  e_len,D1         
0000113E  4E4F                     215              TRAP    #15         
00001140  D3FC 000012EC            216              ADDA.L  #e_len,A1
00001146  103C 0002                217              MOVE.B  #task2,D0
0000114A  4E4F                     218              TRAP    #15
0000114C  4EB9 00001168            219              JSR     ASCII2HEX
00001152  BA3C 0000                220              CMP.B   #$00,D5             *bad input?
00001156  6700 000E                221              BEQ     endInput
0000115A  23C7 0000137C            222              MOVE.L  D7, v_end_add        *store to varable
00001160  4247                     223              CLR     D7
00001162                           224  
00001162                           225  
00001162  2A48                     226              MOVEA.L A0,A5               *store ending to A5
00001164  204C                     227              MOVEA.L A4,A0               *store starting in A0  
00001166                           228                    
00001166  4E75                     229  endInput    RTS
00001168                           230  
00001168                           231  ************************************************************
00001168                           232  *ASCII2HEX 
00001168                           233  *Description: Converts an ASCII character to HEX - see flowchart for logic
00001168                           234  *D3 - Placeholder for current ascii byte
00001168                           235  *D4 - Translated address
00001168                           236  *D5 - Return status
00001168                           237  *D6 - Counter (6)
00001168                           238  *D7 - Temparary register to store address value
00001168                           239  *A0 - Stored address at end of subroutine
00001168                           240  ************************************************************
00001168                           241  ASCII2HEX:
00001168                           242              
00001168  48E7 F800                243              MOVEM.L D0-D4,-(SP)         *save data registers to the stack
0000116C  4EB8 10E6                244              JSR     CLEAR
00001170  1A3C 0001                245              MOVE.B  #$01,D5             *preset flag condition to good
00001174  3C3C 0000                246              MOVE    #length,D6
00001178                           247  
00001178                           248  loop
00001178  1619                     249              MOVE.B  (A1)+,D3            *
0000117A  B63C 0030                250              CMP.B   #$30,D3             *byte < 30??
0000117E  6D00 0056                251              BLT     error               *
00001182                           252              
00001182  B63C 003A                253              CMP.B   #$3A,D3             *byte < 3A??
00001186  6D00 002A                254              BLT     num2hex             *
0000118A                           255              
0000118A  B63C 0041                256              CMP.B   #$41,D3             *byte < 41??
0000118E  6D00 0046                257              BLT     error               *
00001192                           258              
00001192  B63C 0047                259              CMP.B   #$47,D3             *byte < 47?
00001196  6D00 0026                260              BLT     upper2hex           *
0000119A                           261              
0000119A  B63C 0061                262              CMP.B   #$61,D3             *byte < 61??
0000119E  6D00 0036                263              BLT     error               *
000011A2                           264              
000011A2  B63C 0067                265              CMP.B   #$67,D3             *byte < 67??
000011A6  6D00 0022                266              BLT     lower2hex           *
000011AA                           267              
000011AA  B63C 0066                268              CMP.B   #$66,D3             *byte > 66??
000011AE  6E00 0026                269              BGT     error               *
000011B2                           270  
000011B2                           271  num2hex
000011B2  0403 0030                272              SUBI.B  #$30,D3             *subracthex value of 0 to get correct value of input
000011B6  D803                     273              ADD.B   D3,D4               *
000011B8  4EF9 000011E0            274              JMP     resume              *return to top
000011BE                           275              
000011BE                           276  upper2hex
000011BE  0403 0037                277              SUBI.B  #$37,D3             *subracthex value of A to get correct value of input
000011C2  D803                     278              ADD.B   D3,D4               *
000011C4  4EF9 000011E0            279              JMP     resume              *return to top
000011CA                           280              
000011CA                           281  lower2hex
000011CA  0403 0057                282              SUBI.B  #$57,D3             *subracthex value of a to get correct value of input
000011CE  D803                     283              ADD.B   D3,D4               *
000011D0  4EF9 000011E0            284              JMP     resume              *return to top
000011D6                           285  error
000011D6  1A3C 0000                286              MOVE.B  #$00,D5             *flag as bad input and return
000011DA  4EF9 000011F8            287              JMP     endA2H              *return to top
000011E0                           288  resume
000011E0  5246                     289              ADD     #1,D6               *increment length counter
000011E2  BC7C 0006                290              CMP     #6,D6               *check if done
000011E6  6700 0010                291              BEQ     endA2H              *
000011EA  0C11 0000                292              CMP.B   #$00,(A1)           *end of string??
000011EE  6700 0008                293              BEQ     endA2H              *
000011F2  E984                     294              ASL.L   #4,D4               *shiftleft by 4 bits to get next value            
000011F4  4EF8 1178                295              JMP     loop                *return to top
000011F8                           296  
000011F8                           297  endA2H
000011F8  2044                     298              MOVE.L  D4,A0               *
000011FA  2E04                     299              MOVE.L  D4,D7               *move address to temp register
000011FC  4246                     300              CLR     D6                  *clear counter
000011FE  4CDF 001F                301              MOVEM.L (SP)+,D0-D4         *load data registers from stack      
00001202  4E75                     302              RTS                         *
00001204                           303  
00001204                           304  
00001204                           305  
00001204                           306  
00001204                           307  ************************************************************
00001204                           308  *BUFFER_PREP
00001204                           309  ************************************************************
00001204                           310  BUFFER_PREP:  
00001204  244E                     311              MOVEA.L A6,A2         
00001206                           312              *BSR     BUFFER_FILL
00001206  4EB9 00001240            313              JSR     PRINT_NUM
0000120C  103C 0003                314              MOVE.B  #task3, D0
00001210  4E4F                     315              TRAP    #15
00001212  4EB9 0000121C            316              JSR     printinst   
00001218  2458                     317              MOVEA.L (A0)+, A2
0000121A                           318  
0000121A  4E75                     319  endBP       RTS
0000121C                           320  
0000121C                           321  
0000121C                           322  printinst   
0000121C  4240                     323              CLR         D0
0000121E  4241                     324              CLR         D1
00001220  23C8 00001380            325              MOVE.L      A0, v_test
00001226  103C 0003                326              MOVE.B      #task3, D0
0000122A  2239 00001380            327              MOVE.L      v_test, D1
00001230  4E4F                     328              TRAP        #15
00001232                           329              
00001232  4EB8 1078                330              JSR         dis_cr
00001236                           331              
00001236  4E75                     332  end_pi      RTS
00001238                           333                         
00001238                           334  
00001238                           335  
00001238                           336  ************************************************************
00001238                           337  *BUFFER_FILL
00001238                           338  *Description: Fills the buffer with the current address
00001238                           339  ************************************************************
00001238                           340  BUFFER_FILL:
00001238  224A                     341              MOVEA.L     A2, A1
0000123A  14FC 0009                342              MOVE.B      #$09,(A2)+                                   
0000123E  4E75                     343  endFL       RTS
00001240                           344  
00001240                           345  ************************************************************
00001240                           346  *PRINT_NUM
00001240                           347  *Description: Converts the number in D1 to ASCII and prints
00001240                           348  *D3 - Placeholder for current ascii byte
00001240                           349  *D4 - Translated address
00001240                           350  *D5 - Return status
00001240                           351  *D6 - Counter
00001240                           352  *D7 - Temparary register to store address value
00001240                           353  *A0 - Stored address at end of subroutine
00001240                           354  ************************************************************
00001240                           355  PRINT_NUM:
00001240  48E7 FF00                356              MOVEM.L     D0-D7, -(SP)        *
00001244  4EB8 10E6                357              JSR         CLEAR  
00001248  2448                     358              MOVEA.L     A0, A2             *
0000124A  41F9 0000136F            359              LEA         print_stack, A0     *
00001250                           360              
00001250  221A                     361              MOVE.L      (A2)+, D1
00001252  3C3C 0000                362              MOVE.W      #0, D6              *counter
00001256                           363              
00001256  2401                     364  pnLoop1     MOVE.L      D1, D2               *
00001258  E889                     365              LSR.L       #4, D1               *
0000125A  0282 0000000F            366              ANDI.L      #$F, D2              *
00001260  4EB9 00001286            367              JSR         pn_con_letter       *
00001266  10C2                     368              MOVE.B      D2,(A0)+            *push to stack
00001268  5246                     369              ADDI.W      #1, D6               *
0000126A  4A81                     370              TST.L       D1                  *if 0, stop
0000126C  6700 0004                371              BEQ         end_pnLoop1         *
00001270  60E4                     372              BRA         pnLoop1             *
00001272                           373  
00001272                           374  end_pnLoop1
00001272                           375  
00001272                           376  pnLoop2
00001272  4A46                     377              TST.W       D6                  *
00001274  6700 0008                378              BEQ         end_pnLoop2         *stop once all numbers printed
00001278  14E0                     379              MOVE.B      -(A0),(A2)+         *add number to output
0000127A  5346                     380              SUBI.W      #1, D6              *
0000127C  60F4                     381              BRA         pnLoop2             *
0000127E                           382  
0000127E                           383  end_pnLoop2
0000127E  244B                     384              MOVE.L      A3, A2              *
00001280  4CDF 00FF                385              MOVEM.L     (SP)+, D0-D7        *
00001284  4E75                     386              RTS                             *return
00001286                           387  
00001286                           388  pn_con_letter
00001286  B43C 0009                389              CMP.B       #9,D2               *
0000128A  6300 0008                390              BLS         pn_con_digit        *BLS because we want to ignore +/-
0000128E  0602 0037                391              ADDI.B      #$37, D2            *it's a digit A-F, add the right number and RTS
00001292  4E75                     392              RTS                             *return
00001294                           393  pn_con_digit
00001294  0602 0030                394              ADDI.B      #$30,D2             *it's a digit 0-9, add the right number and RTS
00001298  4E75                     395              RTS                             *return
0000129A                           396  
0000129A                           397  ************************************************************
0000129A                           398  *END
0000129A                           399  *Description: Ends program
0000129A                           400  ************************************************************          
0000129A                           401  END:
0000129A  FFFF FFFF                402              SIMHALT              
0000129E                           403           
0000129E                           404  *-----------------------------------------------------------
0000129E                           405  *variables
0000129E                           406  *-----------------------------------------------------------
0000129E= 45 61 73 79 36 38 ...    407  intro       dc.b    'Easy68k Disassembler',0,CR,LF
000012B6= 0018                     408  i_length    dc.w    i_length-intro
000012B8                           409  
000012B8= 45 6E 74 65 72 20 ...    410  srt_addr    dc.b    'Enter starting address: $',0
000012D2= 001A                     411  s_len       dc.w    s_len-srt_addr
000012D4                           412  
000012D4= 45 6E 74 65 72 20 ...    413  end_addr    dc.b    'Enter ending address: $',0
000012EC= 0018                     414  e_len       dc.w    e_len-end_addr
000012EE                           415  
000012EE= 54 68 65 20 73 74 ...    416  t_str_start dc.b    'The start address is: $',0
00001306= 0018                     417  t_start     dc.w    t_start-t_str_start
00001308                           418  
00001308= 54 68 65 20 65 6E ...    419  t_str_end   dc.b    'The end address is: $',0
0000131E= 0016                     420  t_end       dc.w    t_end-t_str_end
00001320                           421  
00001320= 45 72 72 6F 72 3A ...    422  str_error   dc.b    'Error: starting or ending address has error',0
0000134C= 002C                     423  err_len     dc.w    err_len-str_error 
0000134E                           424  
0000134E= 50 72 65 73 73 20 ...    425  str_cont    dc.b    'Press enter to continue.',0
00001368= 001A                     426  cont_len    dc.w    cont_len-str_cont
0000136A                           427  
0000136A= 00                       428  str_cr      dc.b    '',0
0000136C= 0002                     429  cr_len      dc.w    cr_len-str_cr
0000136E                           430  
0000136E= 01                       431  buffer      dc.b    1
0000136F                           432  print_stack ds.b    8
00001377                           433  
00001378                           434  v_srt_add   ds.l    1               *store start address
0000137C                           435  v_end_add   ds.l    1               *store end address
00001380                           436  v_test      ds.l    1               *start a temp value
00001384                           437  
00001384                           438  
00001384                           439      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII2HEX           1168
BADFLAG             0
BUFFER              136E
BUFFER_FILL         1238
BUFFER_PREP         1204
CLEAR               10E6
CONT_LEN            1368
CR                  D
CR_LEN              136C
DIS_BADINPUT        105E
DIS_CONT            108C
DIS_CR              1078
DIS_INTRO_MSG       104A
DIS_TEST            10AC
END                 129A
ENDA2H              11F8
ENDBI               1074
ENDBP               121A
ENDCLEAR            10F6
ENDDC               10AA
ENDFL               123E
ENDINPUT            1166
ENDINTRO            105C
ENDT                10E4
END_ADDR            12D4
END_CR              108A
END_PI              1236
END_PNLOOP1         1272
END_PNLOOP2         127E
ERROR               11D6
ERR_LEN             134C
E_LEN               12EC
GOODFLAG            1
INTRO               129E
I_LENGTH            12B6
LENGTH              0
LF                  A
LOOP                1178
LOWER2HEX           11CA
MAIN                1004
MAIN_CONT           103C
MAIN_END            1046
MAIN_INPUT          1016
MAIN_LOOP           1028
MAIN_TEST           1022
MAXADD              FFFFFF
MINADD              0
NUM2HEX             11B2
PNLOOP1             1256
PNLOOP2             1272
PN_CON_DIGIT        1294
PN_CON_LETTER       1286
PRINTCOUNT          A
PRINTINST           121C
PRINT_NUM           1240
PRINT_STACK         136F
RESUME              11E0
SRT_ADDR            12B8
STACK               A000
START               1000
STR_CONT            134E
STR_CR              136A
STR_ERROR           1320
S_LEN               12D2
TASK0               0
TASK1               1
TASK13              D
TASK14              E
TASK2               2
TASK3               3
T_END               131E
T_START             1306
T_STR_END           1308
T_STR_START         12EE
UPPER2HEX           11BE
U_INPUT             10F8
V_END_ADD           137C
V_SRT_ADD           1378
V_TEST              1380
