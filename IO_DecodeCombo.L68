00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 06/02/20 2:40:58 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Scott Shirley, Carl Howing
00000000                             4  * Date       : June 6, 2020
00000000                             5  * Description: 
00000000                             6  *-----------------------------------------------------------
00000000                             7  *Register Use
00000000                             8  *For consistency, please utilize registers in the following way.
00000000                             9  *
00000000                            10  *D0 -
00000000                            11  *D1 -
00000000                            12  *D2 - copy of working address
00000000                            13  *D3 - utility register
00000000                            14  *D4 -
00000000                            15  *D5 - flag condition
00000000                            16  *D6 - counter
00000000                            17  *D7 -
00000000                            18  *
00000000                            19  *A0 - temp address holder
00000000                            20  *A1 - trap address
00000000                            21  *A2 - buffer address of decoded instruction
00000000                            22  *A3 -
00000000                            23  *A4 - starting address
00000000                            24  *A5 - ending address
00000000                            25  *A6 -
00000000                            26  *A7 -
00000000                            27  *-----------------------------------------------------------
00000000                            28  
00000000                            29  *-----------------------------------------------------------
00000000                            30  * Variables and EQUs
00000000                            31  *-----------------------------------------------------------
00000000  =00001000                 32  start       EQU     $1000               *start address
00000000  =0000A000                 33  stack       EQU     $A000               *stack address  
00000000  =00009000                 34  buf         EQU     $9000
00000000                            35  
00000000  =00000000                 36  minAdd      EQU     $00000000           *start of address space
00000000  =00FFFFFF                 37  maxAdd      EQU     $00FFFFFF           *end of address space
00000000                            38  
00000000  =0000000D                 39  CR          EQU     $0D                 *carriage return
00000000  =0000000A                 40  LF          EQU     $0A                 *line feed
00000000                            41  
00000000  =00000001                 42  goodflag    EQU     1                   *good flag condition
00000000  =00000000                 43  badflag     EQU     0                   *bad flag condition
00000000  =00000000                 44  length      EQU     0                   *
00000000                            45  
00000000  =0000000A                 46  printCount  EQU     10                  *number of lines printed to console before user input
00000000                            47  
00000000                            48  *TRAP tasks for preload
00000000  =00000000                 49  task0       EQU     00                  *Display string at (A1), D1.W bytes long (max 255) with carriage return and line feed (CR, LF)
00000000  =00000001                 50  task1       EQU     01                  *Display string at (A1), D1.W bytes long (max 255) without CR, LF
00000000  =00000002                 51  task2       EQU     02                  *Read string from keyboard and store at (A1), NULL terminated, length retuned in D1.W (max 80)
00000000  =00000003                 52  task3       EQU     03                  *Display signed number in D1.L in decimal in smallest field
00000000  =0000000D                 53  task13      EQU     13                  *Display the NULL terminated string at (A1) with CR, LF
00000000  =0000000E                 54  task14      EQU     14                  *Display the NULL terminated string at (A1) without CR, LF
00000000                            55  
00000000                            56  *-----------------------------------------------------------
00000000                            57  *beging program
00000000                            58  *-----------------------------------------------------------
00001000                            59              ORG     start
00001000  6100 0048                 60              BSR     dis_intro_msg       *print intro message
00001004                            61              
00001004  6100 00E0                 62  main        BSR     CLEAR               *clear all registers
00001008  4FF9 0000A000             63              LEA     stack, SP           *load stack pointer
0000100E  45F9 000013D2             64              LEA     buffer, A2          *set buffer for input
00001014  2C4A                      65              MOVEA.L A2,A6 
00001016                            66              
00001016                            67              
00001016  6100 00E0                 68  main_input  BSR     U_INPUT             *branch to input
0000101A  BA3C 0000                 69              CMP.B   #$0, D5             *check if bad input
0000101E  6700 003E                 70              BEQ     dis_badInput        *bad flag, reinput 
00001022                            71              
00001022                            72              
00001022  4EB9 000010AC             73  main_test   JSR     dis_test            *display inputs
00001028                            74              
00001028  4EB9 00001204             75  main_loop   JSR     BUFFER_PREP         *prep buffer
0000102E                            76  
0000102E                            77  *loop checking      
0000102E  BBC8                      78              CMPA.L  A0, A5              * have we reached the end of our address range?
00001030  6F00 0014                 79              BLE     main_end  
00001034                            80   
00001034  5246                      81              ADDI    #1, D6              *add counter
00001036  BC7C 000A                 82              CMP     #printcount, D6     *check loop progress
0000103A  66EC                      83              BNE     main_loop
0000103C                            84                
0000103C                            85              
0000103C                            86  
0000103C  4EB9 0000108C             87  main_cont   JSR     dis_cont
00001042  4EF8 1028                 88              JMP     main_loop
00001046                            89  
00001046                            90  
00001046                            91  
00001046  6100 02B6                 92  main_end    BSR     END
0000104A                            93  
0000104A                            94  *-----------------------------------------------------------
0000104A                            95  *display subroutines
0000104A                            96  *intro message, bad inputs, carriage return, enter2return, input test
0000104A                            97  *-----------------------------------------------------------
0000104A                            98  *intro message display
0000104A                            99  ************************************************************
0000104A                           100  dis_intro_msg
0000104A  103C 000D                101              MOVE.B  #13,D0              *load task
0000104E  43F9 00001302            102              LEA     intro,A1            *load string
00001054  3239 0000131A            103              MOVE.W  i_length,D1         *load string length 
0000105A  4E4F                     104              TRAP    #15                 *display
0000105C  4E75                     105  endIntro    RTS                         *return
0000105E                           106  
0000105E                           107  *bad input error message display
0000105E                           108  ************************************************************
0000105E                           109  dis_badInput
0000105E  103C 0000                110              MOVE.B  #task0,D0           *load task
00001062  43F9 00001384            111              LEA     str_error, A1       *load string
00001068  3239 000013B0            112              MOVE.W  err_len, D1         *load string length
0000106E  4E4F                     113              TRAP    #15                 *display
00001070  1A3C 0000                114              MOVE.B  #badFlag,D5         *set flag condition to bad
00001074  4EB8 1016                115  endBI       JSR     main_input          *return to main_input
00001078                           116  
00001078                           117  *dsiplay carriage return
00001078                           118  ************************************************************
00001078                           119  dis_cr
00001078  103C 000D                120              MOVE.B  #task13, D0         *load task
0000107C  43F9 000013CE            121              LEA     str_cr, A1          *load string
00001082  3239 000013D0            122              MOVE.W  cr_len, D1          *load string length
00001088  4E4F                     123              TRAP    #15                 *display
0000108A  4E75                     124  end_cr      RTS                         *return
0000108C                           125  
0000108C                           126  *enter2return
0000108C                           127  ************************************************************
0000108C                           128  dis_cont   
0000108C  103C 000E                129              MOVE.B  #task14, D0         *load task
00001090  43F9 000013B2            130              LEA     str_cont, A1        *load string
00001096  3239 000013CC            131              MOVE.W  cont_len, D1        *load string length
0000109C  4E4F                     132              TRAP    #15                 *display
0000109E                           133              
0000109E  103C 0002                134              MOVE.B  #task2,D0           *load task
000010A2  4E4F                     135              TRAP    #15                 *get input
000010A4                           136              
000010A4  12BC 0050                137              MOVE.B  #$50,(A1)           *reset A1
000010A8                           138              
000010A8  4246                     139              CLR     D6                  *clear counter, reset loop
000010AA  4E75                     140  endDC       RTS                         *return
000010AC                           141  
000010AC                           142  
000010AC                           143  *dsiplay input test
000010AC                           144  ************************************************************ 
000010AC                           145  dis_test     
000010AC  103C 000E                146              MOVE.B  #task14, D0         *
000010B0  43F9 00001352            147              LEA     t_str_start, A1     *print start add test message     
000010B6  4E4F                     148              TRAP    #15                 *
000010B8                           149              
000010B8  2239 000013DC            150              MOVE.L  v_srt_add, D1       *
000010BE  103C 0003                151              MOVE.B  #task3, D0          *print start add test value
000010C2  4E4F                     152              TRAP    #15                 *
000010C4                           153              
000010C4  4EB8 1078                154              JSR     dis_cr
000010C8                           155         
000010C8  103C 000E                156              MOVE.B  #task14, D0         *print end add test message
000010CC  43F9 0000136C            157              LEA     t_str_end, A1         *    
000010D2  4E4F                     158              TRAP    #15                 *
000010D4                           159    
000010D4  2239 000013E0            160              MOVE.L  v_end_add, D1       *
000010DA  103C 0003                161              MOVE.B  #task3, D0          *print end add test value
000010DE  4E4F                     162              TRAP    #15                 *
000010E0                           163              
000010E0  4EB8 1078                164              JSR     dis_cr
000010E4  4E75                     165  endT        RTS
000010E6                           166  
000010E6                           167  
000010E6                           168  *-----------------------------------------------------------
000010E6                           169  *helper subroutines
000010E6                           170  *----------------------------------------------------------- 
000010E6                           171  
000010E6                           172  ************************************************************   
000010E6                           173  *CLEAR
000010E6                           174  *Description: Clears registers of values
000010E6                           175  ************************************************************        
000010E6                           176  CLEAR:
000010E6  4240                     177              CLR     D0
000010E8  4241                     178              CLR     D1
000010EA  4242                     179              CLR     D2
000010EC  4243                     180              CLR     D3
000010EE  4244                     181              CLR     D4
000010F0  4245                     182              CLR     D5
000010F2  4246                     183              CLR     D6
000010F4  4247                     184              CLR     D7
000010F6  4E75                     185  endClear    RTS
000010F8                           186  
000010F8                           187  ************************************************************
000010F8                           188  *U_INPUT
000010F8                           189  *Description: Gets input address from user for program
000010F8                           190  *D5 - Return Status
000010F8                           191  *D7 - Temparary register to store address value
000010F8                           192  *A0 - Working Address
000010F8                           193  *A4 - Start Address
000010F8                           194  *A5 - End Address
000010F8                           195  ************************************************************
000010F8                           196  U_INPUT:
000010F8  103C 0001                197              MOVE.B  #task1,D0           *
000010FC  43F9 0000131C            198              LEA     srt_addr,A1         *
00001102  3239 00001336            199              MOVE.W  s_len,D1            *
00001108  4E4F                     200              TRAP    #15                 *
0000110A  D3FC 00001336            201              ADDA.L  #s_len,A1           *
00001110  103C 0002                202              MOVE.B  #task2,D0           *
00001114  4E4F                     203              TRAP    #15                 *
00001116  4EB9 00001168            204              JSR     ASCII2HEX
0000111C  BA3C 0000                205              CMP.B   #$00,D5             *bad input?
00001120  6700 0044                206              BEQ     endInput
00001124  23C7 000013DC            207              MOVE.L  D7, v_srt_add       *store to varable
0000112A  4247                     208              CLR     D7
0000112C                           209              
0000112C  2848                     210              MOVEA.L A0,A4       
0000112E  103C 0001                211              MOVE.B  #task1,D0
00001132  43F9 00001338            212              LEA     end_addr,A1
00001138  3239 00001350            213              MOVE.W  e_len,D1         
0000113E  4E4F                     214              TRAP    #15         
00001140  D3FC 00001350            215              ADDA.L  #e_len,A1
00001146  103C 0002                216              MOVE.B  #task2,D0
0000114A  4E4F                     217              TRAP    #15
0000114C  4EB9 00001168            218              JSR     ASCII2HEX
00001152  BA3C 0000                219              CMP.B   #$00,D5             *bad input?
00001156  6700 000E                220              BEQ     endInput
0000115A  23C7 000013E0            221              MOVE.L  D7, v_end_add        *store to varable
00001160  4247                     222              CLR     D7
00001162                           223  
00001162                           224  
00001162  2A48                     225              MOVEA.L A0,A5               *store ending to A5
00001164  204C                     226              MOVEA.L A4,A0               *store starting in A0  
00001166                           227                    
00001166  4E75                     228  endInput    RTS
00001168                           229  
00001168                           230  ************************************************************
00001168                           231  *ASCII2HEX 
00001168                           232  *Description: Converts an ASCII character to HEX - see flowchart for logic
00001168                           233  *D3 - Placeholder for current ascii byte
00001168                           234  *D4 - Translated address
00001168                           235  *D5 - Return status
00001168                           236  *D6 - Counter (6)
00001168                           237  *D7 - Temparary register to store address value
00001168                           238  *A0 - Stored address at end of subroutine
00001168                           239  ************************************************************
00001168                           240  ASCII2HEX:
00001168                           241              
00001168  48E7 F800                242              MOVEM.L D0-D4,-(SP)         *save data registers to the stack
0000116C  4EB8 10E6                243              JSR     CLEAR
00001170  1A3C 0001                244              MOVE.B  #$01,D5             *preset flag condition to good
00001174  3C3C 0000                245              MOVE    #length,D6
00001178                           246  
00001178                           247  loop
00001178  1619                     248              MOVE.B  (A1)+,D3            *
0000117A  B63C 0030                249              CMP.B   #$30,D3             *byte < 30??
0000117E  6D00 0056                250              BLT     error               *
00001182                           251              
00001182  B63C 003A                252              CMP.B   #$3A,D3             *byte < 3A??
00001186  6D00 002A                253              BLT     num2hex             *
0000118A                           254              
0000118A  B63C 0041                255              CMP.B   #$41,D3             *byte < 41??
0000118E  6D00 0046                256              BLT     error               *
00001192                           257              
00001192  B63C 0047                258              CMP.B   #$47,D3             *byte < 47?
00001196  6D00 0026                259              BLT     upper2hex           *
0000119A                           260              
0000119A  B63C 0061                261              CMP.B   #$61,D3             *byte < 61??
0000119E  6D00 0036                262              BLT     error               *
000011A2                           263              
000011A2  B63C 0067                264              CMP.B   #$67,D3             *byte < 67??
000011A6  6D00 0022                265              BLT     lower2hex           *
000011AA                           266              
000011AA  B63C 0066                267              CMP.B   #$66,D3             *byte > 66??
000011AE  6E00 0026                268              BGT     error               *
000011B2                           269  
000011B2                           270  num2hex
000011B2  0403 0030                271              SUBI.B  #$30,D3             *subracthex value of 0 to get correct value of input
000011B6  D803                     272              ADD.B   D3,D4               *
000011B8  4EF9 000011E0            273              JMP     resume              *return to top
000011BE                           274              
000011BE                           275  upper2hex
000011BE  0403 0037                276              SUBI.B  #$37,D3             *subracthex value of A to get correct value of input
000011C2  D803                     277              ADD.B   D3,D4               *
000011C4  4EF9 000011E0            278              JMP     resume              *return to top
000011CA                           279              
000011CA                           280  lower2hex
000011CA  0403 0057                281              SUBI.B  #$57,D3             *subracthex value of a to get correct value of input
000011CE  D803                     282              ADD.B   D3,D4               *
000011D0  4EF9 000011E0            283              JMP     resume              *return to top
000011D6                           284  error
000011D6  1A3C 0000                285              MOVE.B  #$00,D5             *flag as bad input and return
000011DA  4EF9 000011F8            286              JMP     endA2H              *return to top
000011E0                           287  resume
000011E0  5246                     288              ADD     #1,D6               *increment length counter
000011E2  BC7C 0006                289              CMP     #6,D6               *check if done
000011E6  6700 0010                290              BEQ     endA2H              *
000011EA  0C11 0000                291              CMP.B   #$00,(A1)           *end of string??
000011EE  6700 0008                292              BEQ     endA2H              *
000011F2  E984                     293              ASL.L   #4,D4               *shiftleft by 4 bits to get next value            
000011F4  4EF8 1178                294              JMP     loop                *return to top
000011F8                           295  
000011F8                           296  endA2H
000011F8  2044                     297              MOVE.L  D4,A0               *
000011FA  2E04                     298              MOVE.L  D4,D7               *move address to temp register
000011FC  4246                     299              CLR     D6                  *clear counter
000011FE  4CDF 001F                300              MOVEM.L (SP)+,D0-D4         *load data registers from stack      
00001202  4E75                     301              RTS                         *
00001204                           302  
00001204                           303  
00001204                           304  
00001204                           305  
00001204                           306  ************************************************************
00001204                           307  *BUFFER_PREP
00001204                           308  ************************************************************
00001204                           309  BUFFER_PREP:
00001204  244E                     310              MOVEA.L     A6,A2  
00001206  45F9 00009000            311              LEA         buf, A2
0000120C                           312              
0000120C                           313              *BSR         BYTE2BUFFER
0000120C  6100 0064                314              BSR         WORD2BUFFER
00001210                           315              *BSR         LONG2BUFFER
00001210  4EB9 0000121A            316  printBP     JSR         printinst   
00001216  2448                     317              MOVEA.L     A0, A2
00001218  4E75                     318  endBP       RTS
0000121A                           319  
0000121A                           320  
0000121A                           321  printinst   
0000121A  4240                     322              CLR         D0
0000121C  4241                     323              CLR         D1
0000121E  43F9 00009000            324              LEA         buf, A1
00001224  14BC 0000                325              MOVE.B      #00, (A2)
00001228  103C 000D                326              MOVE.B      #task13, D0
0000122C  4E4F                     327              TRAP        #15
0000122E                           328              
0000122E  4E75                     329  end_pi      RTS
00001230                           330                         
00001230                           331  
00001230                           332  
00001230                           333  ************************************************************
00001230                           334  *BUFFER_FILL
00001230                           335  *Description: Fills the buffer with the current address
00001230                           336  ************************************************************
00001230                           337  BUFFER_FILL:
00001230  224A                     338             MOVEA.L  A2,A1              *load trap address with A2            
00001232                           339             *JSR      getLong
00001232  14FC 0009                340             MOVE.B   #$09,(A2)+                                  
00001236  4E75                     341  endFL      RTS
00001238                           342  
00001238                           343  
00001238                           344  *----------------------------------------------------------- 
00001238                           345  *CONVERT2BUFFER
00001238                           346  *Description: Puts word to print buffer
00001238                           347  *D3 - Utility register
00001238                           348  *D6 - Counter
00001238                           349  *A0 - Utility address
00001238                           350  *A2 - Address buffer
00001238                           351  
00001238                           352  *----------------------------------------------------------- 
00001238                           353  
00001238                           354  ************************************************************
00001238                           355  *BYTE2BUFFER
00001238                           356  *Buffer: $XX
00001238                           357  ************************************************************
00001238                           358  BYTE2BUFFER:
00001238  48E7 FE00                359              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
0000123C  14FC 0024                360              MOVE.B      #'$', (A2)+  
00001240  4284                     361              CLR.L       D4                  *clear counter
00001242  2E88                     362              MOVE.L      A0, (A7)
00001244  2E17                     363              MOVE.L      (A7), D7
00001246  2417                     364              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
00001248  183C 0002                365              MOVE.B      #2, D4              *load counter
0000124C                           366  
0000124C                           367  b2bLoop                 
0000124C  B83C 0000                368              CMP.B       #$00, D4            *compare counter with 0
00001250  6700 0016                369              BEQ         endb2b              *if zero, return
00001254  E95A                     370              ROL.W       #4, D2              *roll the bits in D2 to the left
00001256  3602                     371              MOVE.W      D2, D3              *move rolled bits into temp storage
00001258  0243 000F                372              ANDI.W      #$000F, D3          *and the bits to isolate ascii char   
0000125C  4EB9 000012E6            373              JSR         HEX2ASCII           *load ascii char into buffer            
00001262  5304                     374              SUBQ.B      #$1, D4             *subtract from counter
00001264  4EF8 124C                375              JMP         b2bLoop             *keep looping until counter hits zero
00001268                           376              
00001268  3607                     377  endb2b      MOVE.W      D7, D3              *re-load current word for temp storage            
0000126A  5448                     378              ADDQ.W      #2, A0              *advancing memory pointer by word  
0000126C  4CDF 007F                379              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
00001270  4E75                     380              RTS                             *return
00001272                           381  ************************************************************
00001272                           382  *WORD2BUFFER
00001272                           383  *Buffer: $XXXX
00001272                           384  ************************************************************
00001272                           385  WORD2BUFFER:
00001272  48E7 FE00                386              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
00001276  14FC 0024                387              MOVE.B      #'$', (A2)+  
0000127A  4284                     388              CLR.L       D4                  *clear counter
0000127C  2E88                     389              MOVE.L      A0, (A7)
0000127E  2E17                     390              MOVE.L      (A7), D7
00001280  2417                     391              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
00001282  183C 0004                392              MOVE.B      #4, D4              *load counter
00001286                           393  
00001286                           394  w2bLoop                 
00001286  B83C 0000                395              CMP.B       #$00, D4            *compare counter with 0
0000128A  6700 0016                396              BEQ         endw2b              *if zero, return
0000128E  E95A                     397              ROL.W       #4, D2              *roll the bits in D2 to the left
00001290  3602                     398              MOVE.W      D2, D3              *move rolled bits into temp storage
00001292  0243 000F                399              ANDI.W      #$000F, D3          *and the bits to isolate ascii char   
00001296  4EB9 000012E6            400              JSR         HEX2ASCII           *load ascii char into buffer            
0000129C  5304                     401              SUBQ.B      #$1, D4             *subtract from counter
0000129E  4EF8 1286                402              JMP         w2bLoop             *keep looping until counter hits zero
000012A2                           403              
000012A2  3607                     404  endw2b      MOVE.W      D7, D3              *re-load current word for temp storage            
000012A4  5448                     405              ADDQ.W      #2, A0              *advancing memory pointer by word  
000012A6  4CDF 007F                406              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
000012AA  4E75                     407              RTS                             *return
000012AC                           408   
000012AC                           409  ************************************************************
000012AC                           410  *LONG2BUFFER
000012AC                           411  *Buffer: $XXXXXXXX
000012AC                           412  ************************************************************           
000012AC                           413  LONG2BUFFER:
000012AC  48E7 FE00                414              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
000012B0  14FC 0024                415              MOVE.B      #'$', (A2)+  
000012B4  4284                     416              CLR.L       D4                  *clear counter
000012B6  2E88                     417              MOVE.L      A0, (A7)
000012B8  2E17                     418              MOVE.L      (A7), D7
000012BA  2417                     419              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
000012BC  183C 0008                420              MOVE.B      #8, D4              *load counter
000012C0                           421  
000012C0                           422  l2bLoop                 
000012C0  B83C 0000                423              CMP.B       #$00, D4            *compare counter with 0
000012C4  6700 0016                424              BEQ         endl2b              *if zero, return
000012C8  E95A                     425              ROL.W       #4, D2              *roll the bits in D2 to the left
000012CA  3602                     426              MOVE.W      D2, D3              *move rolled bits into temp storage
000012CC  0243 000F                427              ANDI.W      #$000F, D3          *and the bits to isolate ascii char   
000012D0  4EB9 000012E6            428              JSR         HEX2ASCII           *load ascii char into buffer            
000012D6  5304                     429              SUBQ.B      #$1, D4             *subtract from counter
000012D8  4EF8 12C0                430              JMP         l2bLoop             *keep looping until counter hits zero
000012DC                           431              
000012DC  3607                     432  endl2b      MOVE.W      D7, D3              *re-load current word for temp storage            
000012DE  5848                     433              ADDQ.W      #4, A0              *advancing memory pointer by word  
000012E0  4CDF 007F                434              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
000012E4  4E75                     435              RTS   
000012E6                           436  ************************************************************
000012E6                           437  *HEX2ASCII
000012E6                           438  ************************************************************            
000012E6                           439  HEX2ASCII:  
000012E6  B63C 000A                440              CMP.B       #$A, D3             * Confirm hex character?
000012EA  6C00 000A                441              BGE         letter              * Is it a letter or number?
000012EE  0603 0030                442              ADDI.B      #$30,D3             * Convert decimal to ASCII
000012F2  6000 0006                443              BRA         write2Buff          * save to good buffer
000012F6  0603 0037                444  letter      ADDI.B      #$37,D3
000012FA  14C3                     445  write2Buff  MOVE.B      D3,(A2)+
000012FC  4E75                     446              RTS
000012FE                           447              
000012FE                           448  
000012FE                           449  
000012FE                           450  ************************************************************
000012FE                           451  *END
000012FE                           452  *Description: Ends program
000012FE                           453  ************************************************************          
000012FE                           454  END:
000012FE  FFFF FFFF                455              SIMHALT              
00001302                           456           
00001302                           457  *-----------------------------------------------------------
00001302                           458  *variables
00001302                           459  *-----------------------------------------------------------
00001302= 45 61 73 79 36 38 ...    460  intro       dc.b    'Easy68k Disassembler',0,CR,LF
0000131A= 0018                     461  i_length    dc.w    i_length-intro
0000131C                           462  
0000131C= 45 6E 74 65 72 20 ...    463  srt_addr    dc.b    'Enter starting address: $',0
00001336= 001A                     464  s_len       dc.w    s_len-srt_addr
00001338                           465  
00001338= 45 6E 74 65 72 20 ...    466  end_addr    dc.b    'Enter ending address: $',0
00001350= 0018                     467  e_len       dc.w    e_len-end_addr
00001352                           468  
00001352= 54 68 65 20 73 74 ...    469  t_str_start dc.b    'The start address is: $',0
0000136A= 0018                     470  t_start     dc.w    t_start-t_str_start
0000136C                           471  
0000136C= 54 68 65 20 65 6E ...    472  t_str_end   dc.b    'The end address is: $',0
00001382= 0016                     473  t_end       dc.w    t_end-t_str_end
00001384                           474  
00001384= 45 72 72 6F 72 3A ...    475  str_error   dc.b    'Error: starting or ending address has error',0
000013B0= 002C                     476  err_len     dc.w    err_len-str_error 
000013B2                           477  
000013B2= 50 72 65 73 73 20 ...    478  str_cont    dc.b    'Press enter to continue.',0
000013CC= 001A                     479  cont_len    dc.w    cont_len-str_cont
000013CE                           480  
000013CE= 00                       481  str_cr      dc.b    '',0
000013D0= 0002                     482  cr_len      dc.w    cr_len-str_cr
000013D2                           483  
000013D2= 01                       484  buffer      dc.b    1
000013D3                           485  print_stack ds.b    8
000013DB                           486  
000013DC                           487  v_srt_add   ds.l    1               *store start address
000013E0                           488  v_end_add   ds.l    1               *store end address
000013E4                           489  v_test      ds.l    1               *start a temp value
000013E8                           490  
000013E8                           491  
000013E8                           492      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII2HEX           1168
B2BLOOP             124C
BADFLAG             0
BUF                 9000
BUFFER              13D2
BUFFER_FILL         1230
BUFFER_PREP         1204
BYTE2BUFFER         1238
CLEAR               10E6
CONT_LEN            13CC
CR                  D
CR_LEN              13D0
DIS_BADINPUT        105E
DIS_CONT            108C
DIS_CR              1078
DIS_INTRO_MSG       104A
DIS_TEST            10AC
END                 12FE
ENDA2H              11F8
ENDB2B              1268
ENDBI               1074
ENDBP               1218
ENDCLEAR            10F6
ENDDC               10AA
ENDFL               1236
ENDINPUT            1166
ENDINTRO            105C
ENDL2B              12DC
ENDT                10E4
ENDW2B              12A2
END_ADDR            1338
END_CR              108A
END_PI              122E
ERROR               11D6
ERR_LEN             13B0
E_LEN               1350
GOODFLAG            1
HEX2ASCII           12E6
INTRO               1302
I_LENGTH            131A
L2BLOOP             12C0
LENGTH              0
LETTER              12F6
LF                  A
LONG2BUFFER         12AC
LOOP                1178
LOWER2HEX           11CA
MAIN                1004
MAIN_CONT           103C
MAIN_END            1046
MAIN_INPUT          1016
MAIN_LOOP           1028
MAIN_TEST           1022
MAXADD              FFFFFF
MINADD              0
NUM2HEX             11B2
PRINTBP             1210
PRINTCOUNT          A
PRINTINST           121A
PRINT_STACK         13D3
RESUME              11E0
SRT_ADDR            131C
STACK               A000
START               1000
STR_CONT            13B2
STR_CR              13CE
STR_ERROR           1384
S_LEN               1336
TASK0               0
TASK1               1
TASK13              D
TASK14              E
TASK2               2
TASK3               3
T_END               1382
T_START             136A
T_STR_END           136C
T_STR_START         1352
UPPER2HEX           11BE
U_INPUT             10F8
V_END_ADD           13E0
V_SRT_ADD           13DC
V_TEST              13E4
W2BLOOP             1286
WORD2BUFFER         1272
WRITE2BUFF          12FA
