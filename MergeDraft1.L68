00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 06/02/20 11:33:40 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Scott Shirley, Carl Howing
00000000                             4  * Date       : June 6, 2020
00000000                             5  * Description: 
00000000                             6  ************************************************************
00000000                             7  
00000000                             8  ************************************************************
00000000                             9  *  ____            _     _                
00000000                            10  * |  _ \ ___  __ _(_)___| |_ ___ _ __ ___ 
00000000                            11  * | |_) / _ \/ _` | / __| __/ _ \ '__/ __|
00000000                            12  * |  _ <  __/ (_| | \__ \ ||  __/ |  \__ \
00000000                            13  * |_| \_\___|\__, |_|___/\__\___|_|  |___/
00000000                            14  *            |___/                        
00000000                            15  *Register Use
00000000                            16  *For consistency, please utilize registers in the following way.
00000000                            17  *
00000000                            18  *D0 -
00000000                            19  *D1 -
00000000                            20  *D2 - 
00000000                            21  *D3 - utility register
00000000                            22  *D4 -
00000000                            23  *D5 - flag condition
00000000                            24  *D6 - counter
00000000                            25  *D7 - copy of working address
00000000                            26  *
00000000                            27  *A0 - temp address holder
00000000                            28  *A1 - trap address
00000000                            29  *A2 - buffer address of decoded instruction
00000000                            30  *A3 -
00000000                            31  *A4 - starting address
00000000                            32  *A5 - ending address
00000000                            33  *A6 -
00000000                            34  *A7 -
00000000                            35  ************************************************************
00000000                            36  
00000000                            37  ************************************************************
00000000                            38  * __     __         _       _     _                               _     _____ ___  _   _ 
00000000                            39  * \ \   / /_ _ _ __(_) __ _| |__ | | ___  ___      __ _ _ __   __| |   | ____/ _ \| | | |
00000000                            40  *  \ \ / / _` | '__| |/ _` | '_ \| |/ _ \/ __|    / _` | '_ \ / _` |   |  _|| | | | | | |
00000000                            41  *   \ V / (_| | |  | | (_| | |_) | |  __/\__ \   | (_| | | | | (_| |   | |__| |_| | |_| |
00000000                            42  *    \_/ \__,_|_|  |_|\__,_|_.__/|_|\___||___/    \__,_|_| |_|\__,_|   |_____\__\_\\___/ 
00000000                            43  *                                                                                        
00000000                            44  * Variables and EQUs
00000000                            45  ************************************************************
00000000  =00001000                 46  start       EQU     $1000               *start address
00000000  =0000A000                 47  stack       EQU     $A000               *stack address  
00000000  =00009000                 48  buf         EQU     $9000
00000000                            49  
00000000  =00000000                 50  minAdd      EQU     $00000000           *start of address space
00000000  =00FFFFFF                 51  maxAdd      EQU     $00FFFFFF           *end of address space
00000000                            52  
00000000  =0000000D                 53  CR          EQU     $0D                 *carriage return
00000000  =0000000A                 54  LF          EQU     $0A                 *line feed
00000000                            55  
00000000  =00000001                 56  goodflag    EQU     1                   *good flag condition
00000000  =00000000                 57  badflag     EQU     0                   *bad flag condition
00000000  =00000000                 58  length      EQU     0                   *
00000000                            59  
00000000  =0000000A                 60  printCount  EQU     10                  *number of lines printed to console before user input
00000000                            61  
00000000                            62  *TRAP tasks for preload
00000000  =00000000                 63  task0       EQU     00                  *Display string at (A1), D1.W bytes long (max 255) with carriage return and line feed (CR, LF)
00000000  =00000001                 64  task1       EQU     01                  *Display string at (A1), D1.W bytes long (max 255) without CR, LF
00000000  =00000002                 65  task2       EQU     02                  *Read string from keyboard and store at (A1), NULL terminated, length retuned in D1.W (max 80)
00000000  =00000003                 66  task3       EQU     03                  *Display signed number in D1.L in decimal in smallest field
00000000  =0000000D                 67  task13      EQU     13                  *Display the NULL terminated string at (A1) with CR, LF
00000000  =0000000E                 68  task14      EQU     14                  *Display the NULL terminated string at (A1) without CR, LF
00000000                            69  ************************************************************
00000000                            70  
00000000                            71  ************************************************************
00000000                            72  *  __  __       _       
00000000                            73  * |  \/  | __ _(_)_ __  
00000000                            74  * | |\/| |/ _` | | '_ \ 
00000000                            75  * | |  | | (_| | | | | |
00000000                            76  * |_|  |_|\__,_|_|_| |_|
00000000                            77  *                      
00000000                            78  ************************************************************
00001000                            79              ORG     start
00001000  6100 0042                 80              BSR     dis_intro_msg       *print intro message
00001004                            81              
00001004                            82              
00001004  6100 00A0                 83  main        BSR     CLEAR               *clear all registers
00001008  4FF9 0000A000             84              LEA     stack, SP           *load stack pointer
0000100E  45F9 00001770             85              LEA     buffer, A2          *set buffer for input
00001014  2C4A                      86              MOVEA.L A2,A6 
00001016                            87              
00001016                            88              
00001016  6100 00A0                 89  main_input  BSR     U_INPUT             *branch to input
0000101A  BA3C 0000                 90              CMP.B   #$0, D5             *check if bad input
0000101E  6700 0038                 91              BEQ     dis_badInput        *bad flag, reinput 
00001022                            92                          
00001022  4EB9 000011C4             93  main_loop   JSR     BUFFER_PREP         *prep buffer
00001028                            94  
00001028                            95  *loop checking      
00001028  BBC8                      96              CMPA.L  A0, A5              * have we reached the end of our address range?
0000102A  6F00 0014                 97              BLE     main_end  
0000102E                            98   
0000102E  5246                      99              ADDI    #1, D6              *add counter
00001030  BC7C 000A                100              CMP     #printcount, D6     *check loop progress
00001034  66EC                     101              BNE     main_loop
00001036                           102                
00001036                           103              
00001036                           104  
00001036  4EB9 00001086            105  main_cont   JSR     dis_cont
0000103C  4EF8 1022                106              JMP     main_loop
00001040                           107  
00001040  6100 065A                108  main_end    BSR     END
00001044                           109  *===========================================================
00001044                           110  
00001044                           111  *-----------------------------------------------------------
00001044                           112  *display subroutines
00001044                           113  *intro message, bad inputs, carriage return, enter2return, input test
00001044                           114  *-----------------------------------------------------------
00001044                           115  *intro message display
00001044                           116  ************************************************************
00001044                           117  dis_intro_msg
00001044  103C 000D                118              MOVE.B  #13,D0              *load task
00001048  43F9 000016A0            119              LEA     intro,A1            *load string
0000104E  3239 000016B8            120              MOVE.W  i_length,D1         *load string length 
00001054  4E4F                     121              TRAP    #15                 *display
00001056  4E75                     122  endIntro    RTS                         *return
00001058                           123  
00001058                           124  *bad input error message display
00001058                           125  ************************************************************
00001058                           126  dis_badInput
00001058  103C 0000                127              MOVE.B  #task0,D0           *load task
0000105C  43F9 00001722            128              LEA     str_error, A1       *load string
00001062  3239 0000174E            129              MOVE.W  err_len, D1         *load string length
00001068  4E4F                     130              TRAP    #15                 *display
0000106A  1A3C 0000                131              MOVE.B  #badFlag,D5         *set flag condition to bad
0000106E  4EB8 1016                132  endBI       JSR     main_input          *return to main_input
00001072                           133  
00001072                           134  *dsiplay carriage return
00001072                           135  ************************************************************
00001072                           136  dis_cr
00001072  103C 000D                137              MOVE.B  #task13, D0         *load task
00001076  43F9 0000176C            138              LEA     str_cr, A1          *load string
0000107C  3239 0000176E            139              MOVE.W  cr_len, D1          *load string length
00001082  4E4F                     140              TRAP    #15                 *display
00001084  4E75                     141  end_cr      RTS                         *return
00001086                           142  
00001086                           143  *enter2return
00001086                           144  ************************************************************
00001086                           145  dis_cont   
00001086  103C 000E                146              MOVE.B  #task14, D0         *load task
0000108A  43F9 00001750            147              LEA     str_cont, A1        *load string
00001090  3239 0000176A            148              MOVE.W  cont_len, D1        *load string length
00001096  4E4F                     149              TRAP    #15                 *display
00001098                           150              
00001098  103C 0002                151              MOVE.B  #task2,D0           *load task
0000109C  4E4F                     152              TRAP    #15                 *get input
0000109E                           153              
0000109E  12BC 0050                154              MOVE.B  #$50,(A1)           *reset A1
000010A2                           155              
000010A2  4246                     156              CLR     D6                  *clear counter, reset loop
000010A4  4E75                     157  endDC       RTS                         *return
000010A6                           158  *===========================================================
000010A6                           159  
000010A6                           160  ************************************************************ 
000010A6                           161  *  _   _ _____ _     ____  _____ ____  
000010A6                           162  * | | | | ____| |   |  _ \| ____|  _ \ 
000010A6                           163  * | |_| |  _| | |   | |_) |  _| | |_) |
000010A6                           164  * |  _  | |___| |___|  __/| |___|  _ < 
000010A6                           165  * |_| |_|_____|_____|_|   |_____|_| \_\
000010A6                           166  *                                      
000010A6                           167  *HELPER SUBROUTINES
000010A6                           168  *Description: These subroutines are called during teh opcode translation
000010A6                           169  ************************************************************
000010A6                           170  
000010A6                           171  ************************************************************   
000010A6                           172  *CLEAR
000010A6                           173  *Description: Clears registers of values
000010A6                           174  ************************************************************        
000010A6                           175  CLEAR:
000010A6  4240                     176              CLR     D0
000010A8  4241                     177              CLR     D1
000010AA  4242                     178              CLR     D2
000010AC  4243                     179              CLR     D3
000010AE  4244                     180              CLR     D4
000010B0  4245                     181              CLR     D5
000010B2  4246                     182              CLR     D6
000010B4  4247                     183              CLR     D7
000010B6  4E75                     184  endClear    RTS
000010B8                           185  *===========================================================
000010B8                           186  
000010B8                           187  ************************************************************
000010B8                           188  *U_INPUT
000010B8                           189  *Description: Gets input address from user for program
000010B8                           190  *D5 - Return Status
000010B8                           191  *D7 - Temparary register to store address value
000010B8                           192  *A0 - Working Address
000010B8                           193  *A4 - Start Address
000010B8                           194  *A5 - End Address
000010B8                           195  ************************************************************
000010B8                           196  U_INPUT:
000010B8  103C 0001                197              MOVE.B  #task1,D0           *
000010BC  43F9 000016BA            198              LEA     srt_addr,A1         *
000010C2  3239 000016D4            199              MOVE.W  s_len,D1            *
000010C8  4E4F                     200              TRAP    #15                 *
000010CA  D3FC 000016D4            201              ADDA.L  #s_len,A1           *
000010D0  103C 0002                202              MOVE.B  #task2,D0           *
000010D4  4E4F                     203              TRAP    #15                 *
000010D6  4EB9 00001128            204              JSR     ASCII2HEX
000010DC  BA3C 0000                205              CMP.B   #$00,D5             *bad input?
000010E0  6700 0044                206              BEQ     endInput
000010E4  23C7 0000177A            207              MOVE.L  D7, v_srt_add       *store to varable
000010EA  4247                     208              CLR     D7
000010EC                           209              
000010EC  2848                     210              MOVEA.L A0,A4       
000010EE  103C 0001                211              MOVE.B  #task1,D0
000010F2  43F9 000016D6            212              LEA     end_addr,A1
000010F8  3239 000016EE            213              MOVE.W  e_len,D1         
000010FE  4E4F                     214              TRAP    #15         
00001100  D3FC 000016EE            215              ADDA.L  #e_len,A1
00001106  103C 0002                216              MOVE.B  #task2,D0
0000110A  4E4F                     217              TRAP    #15
0000110C  4EB9 00001128            218              JSR     ASCII2HEX
00001112  BA3C 0000                219              CMP.B   #$00,D5             *bad input?
00001116  6700 000E                220              BEQ     endInput
0000111A  23C7 0000177E            221              MOVE.L  D7, v_end_add        *store to varable
00001120  4247                     222              CLR     D7
00001122                           223  
00001122                           224  
00001122  2A48                     225              MOVEA.L A0,A5               *store ending to A5
00001124  204C                     226              MOVEA.L A4,A0               *store starting in A0  
00001126                           227                    
00001126  4E75                     228  endInput    RTS
00001128                           229  *===========================================================
00001128                           230  
00001128                           231  ************************************************************
00001128                           232  *ASCII2HEX 
00001128                           233  *Description: Converts an ASCII character to HEX - see flowchart for logic
00001128                           234  *D3 - Placeholder for current ascii byte
00001128                           235  *D4 - Translated address
00001128                           236  *D5 - Return status
00001128                           237  *D6 - Counter (6)
00001128                           238  *D7 - Temparary register to store address value
00001128                           239  *A0 - Stored address at end of subroutine
00001128                           240  ************************************************************
00001128                           241  ASCII2HEX:
00001128                           242              
00001128  48E7 F800                243              MOVEM.L D0-D4,-(SP)         *save data registers to the stack
0000112C  4EB8 10A6                244              JSR     CLEAR
00001130  1A3C 0001                245              MOVE.B  #$01,D5             *preset flag condition to good
00001134  3C3C 0000                246              MOVE    #length,D6
00001138                           247  
00001138                           248  loop
00001138  1619                     249              MOVE.B  (A1)+,D3            *
0000113A  B63C 0030                250              CMP.B   #$30,D3             *byte < 30??
0000113E  6D00 0056                251              BLT     error               *
00001142                           252              
00001142  B63C 003A                253              CMP.B   #$3A,D3             *byte < 3A??
00001146  6D00 002A                254              BLT     num2hex             *
0000114A                           255              
0000114A  B63C 0041                256              CMP.B   #$41,D3             *byte < 41??
0000114E  6D00 0046                257              BLT     error               *
00001152                           258              
00001152  B63C 0047                259              CMP.B   #$47,D3             *byte < 47?
00001156  6D00 0026                260              BLT     upper2hex           *
0000115A                           261              
0000115A  B63C 0061                262              CMP.B   #$61,D3             *byte < 61??
0000115E  6D00 0036                263              BLT     error               *
00001162                           264              
00001162  B63C 0067                265              CMP.B   #$67,D3             *byte < 67??
00001166  6D00 0022                266              BLT     lower2hex           *
0000116A                           267              
0000116A  B63C 0066                268              CMP.B   #$66,D3             *byte > 66??
0000116E  6E00 0026                269              BGT     error               *
00001172                           270  
00001172                           271  num2hex
00001172  0403 0030                272              SUBI.B  #$30,D3             *subracthex value of 0 to get correct value of input
00001176  D803                     273              ADD.B   D3,D4               *
00001178  4EF9 000011A0            274              JMP     resume              *return to top
0000117E                           275              
0000117E                           276  upper2hex
0000117E  0403 0037                277              SUBI.B  #$37,D3             *subracthex value of A to get correct value of input
00001182  D803                     278              ADD.B   D3,D4               *
00001184  4EF9 000011A0            279              JMP     resume              *return to top
0000118A                           280              
0000118A                           281  lower2hex
0000118A  0403 0057                282              SUBI.B  #$57,D3             *subracthex value of a to get correct value of input
0000118E  D803                     283              ADD.B   D3,D4               *
00001190  4EF9 000011A0            284              JMP     resume              *return to top
00001196                           285  error
00001196  1A3C 0000                286              MOVE.B  #$00,D5             *flag as bad input and return
0000119A  4EF9 000011B8            287              JMP     endA2H              *return to top
000011A0                           288  resume
000011A0  5246                     289              ADD     #1,D6               *increment length counter
000011A2  BC7C 0006                290              CMP     #6,D6               *check if done
000011A6  6700 0010                291              BEQ     endA2H              *
000011AA  0C11 0000                292              CMP.B   #$00,(A1)           *end of string??
000011AE  6700 0008                293              BEQ     endA2H              *
000011B2  E984                     294              ASL.L   #4,D4               *shiftleft by 4 bits to get next value            
000011B4  4EF8 1138                295              JMP     loop                *return to top
000011B8                           296  
000011B8                           297  endA2H
000011B8  2044                     298              MOVE.L  D4,A0               *
000011BA  2E04                     299              MOVE.L  D4,D7               *move address to temp register
000011BC  4246                     300              CLR     D6                  *clear counter
000011BE  4CDF 001F                301              MOVEM.L (SP)+,D0-D4         *load data registers from stack      
000011C2  4E75                     302              RTS                         *
000011C4                           303  *===========================================================
000011C4                           304  
000011C4                           305  
000011C4                           306  
000011C4                           307  ************************************************************
000011C4                           308  *BUFFER_PREP
000011C4                           309  ************************************************************
000011C4                           310  BUFFER_PREP:
000011C4  4279 00001770            311              CLR     buffer
000011CA                           312              *MOVE.B  D7, D3
000011CA                           313              *MOVE.L  #$9641, D7      *'SUB D1, D3' to instruction register
000011CA                           314              *MOVE.L  #$1601, D7      *'MOVE.B  D1, D3' 
000011CA  2E10                     315              MOVE.L  (A0), D7
000011CC  45F9 00001770            316              LEA     buffer, A2      *load buffer to address
000011D2  6100 0026                317              BSR     GETOPCODE       *beging SUB subroutine
000011D6                           318  
000011D6                           319  
000011D6  4EB9 000011E0            320  printBP     JSR         printinst  
000011DC  5448                     321              ADDQ.W      #2, A0      *advancing memory pointer by word  
000011DE  4E75                     322  endBP       RTS
000011E0                           323  
000011E0                           324  
000011E0                           325  printinst   
000011E0                           326              *print to console
000011E0  14BC 0000                327              MOVE.B  #00, (A2)
000011E4  103C 000D                328              MOVE.B  #13, D0
000011E8  43F9 00001770            329              LEA     buffer, A1
000011EE  4E4F                     330              TRAP    #15
000011F0                           331  
000011F0                           332              
000011F0  4E75                     333  end_pi      RTS
000011F2                           334  *===========================================================                       
000011F2                           335  
000011F2                           336  ************************************************************
000011F2                           337  *BUFFER_FILL
000011F2                           338  *Description: Fills the buffer with the current address
000011F2                           339  ************************************************************
000011F2                           340  BUFFER_FILL:
000011F2  224A                     341             MOVEA.L  A2,A1              *load trap address with A2            
000011F4                           342             *JSR      getLong
000011F4  14FC 0009                343             MOVE.B   #$09,(A2)+                                  
000011F8  4E75                     344  endbf      RTS
000011FA                           345  *===========================================================
000011FA                           346  
000011FA                           347  ************************************************************ 
000011FA                           348  *   ___  ____   ____ ___  ____  _____ ____  
000011FA                           349  *  / _ \|  _ \ / ___/ _ \|  _ \| ____/ ___| 
000011FA                           350  * | | | | |_) | |  | | | | | | |  _| \___ \ 
000011FA                           351  * | |_| |  __/| |__| |_| | |_| | |___ ___) |
000011FA                           352  *  \___/|_|    \____\___/|____/|_____|____/ 
000011FA                           353  * 
000011FA                           354  *GETOPCODE:
000011FA                           355  *Description: Gets the first four bits of instruction to decode                                  
000011FA                           356  *Registers Used:
000011FA                           357  *For consistency, please utilize registers in the following way.
000011FA                           358  *
000011FA                           359  *D1 - utility register
000011FA                           360  *D3 - utility register
000011FA                           361  *D7 - copy of working address
000011FA                           362  *
000011FA                           363  *A2 - buffer address of decoded instruction
000011FA                           364  *A6 - jump table               
000011FA                           365  ************************************************************
000011FA                           366  GETOPCODE:   
000011FA  3607                     367              MOVE.W  D7, D3              *move to utility
000011FC  123C 000C                368              MOVE.B  #12, D1             *
00001200  E26B                     369              LSR.W   D1, D3              *shift
00001202  C6FC 0006                370              MULU    #6, D3              *offset          
00001206  4DF9 00001212            371              LEA     OP_TABLE, A6        *                                                                                  
0000120C  4EB6 3000                372              JSR     00(A6,D3)           *jump indirect with index (00 indicates word movement)
00001210  4E75                     373  endgop      RTS                         *return
00001212                           374  *===========================================================
00001212                           375  
00001212                           376  ************************************************************
00001212                           377  *OPCODE Table
00001212                           378  *Description: Table of OPCODES
00001212                           379  ************************************************************ 
00001212                           380  OP_TABLE
00001212  4EF9 00001272            381              JMP         code0000
00001218  4EF9 00001278            382              JMP         code0001
0000121E  4EF9 000012AC            383              JMP         code0010
00001224  4EF9 000012AC            384              JMP         code0011
0000122A  4EF9 000012AC            385              JMP         code0100
00001230  4EF9 000012AC            386              JMP         code0101
00001236  4EF9 000012AC            387              JMP         code0110
0000123C  4EF9 000012AC            388              JMP         code0111
00001242  4EF9 000012AC            389              JMP         code1000
00001248  4EF9 000012AC            390              JMP         code1001
0000124E  4EF9 0000135A            391              JMP         code1010
00001254  4EF9 0000135A            392              JMP         code1011
0000125A  4EF9 0000135A            393              JMP         code1100
00001260  4EF9 000013E2            394              JMP         code1101
00001266  4EF9 000013E2            395              JMP         code1110
0000126C  4EF9 000013E2            396              JMP         code1111
00001272                           397              
00001272                           398  ************************************************************
00001272                           399  *OPCODES
00001272                           400  *Description: OPCODE subroutines used to decode instructions
00001272                           401  ************************************************************          
00001272                           402  
00001272                           403  *SUB
00001272                           404  *Cases for first four bits: 1001
00001272                           405  *Description: Converts opcode instruction that start with 1001
00001272                           406  *SUB, SUBA
00001272                           407  * 1001 0110 0100 0001
00001272                           408  * ^--^
00001272                           409  *Registers Used:
00001272                           410  *D3 - size bit
00001272                           411  *D7 - copy of instruction
00001272                           412  *A2 - buffer address of decoded instruction
00001272                           413  *
00001272                           414  ************************************************************  
00001272                           415  * Case for: 0000
00001272                           416  * --(ORI,ANDI,SUBI,ADDI,EORI,CMPI) 
00001272  4EF9 0000167C            417  code0000:   JMP     BADINST
00001278                           418  *===========================================================
00001278                           419  
00001278                           420  ************************************************************  
00001278                           421  * Case for: 0001
00001278                           422  * --(MOVE.B)
00001278                           423  code0001:
00001278  14FC 004D                424              MOVE.B  #$4D, (A2)+     *'M' to buffer
0000127C  14FC 004F                425              MOVE.B  #$4F, (A2)+     *'O' to buffer
00001280  14FC 0056                426              MOVE.B  #$56, (A2)+     *'V' to buffer
00001284  14FC 0045                427              MOVE.B  #$45, (A2)+     *'E' to buffer
00001288  14FC 002E                428              MOVE.B  #$2E, (A2)+     *'.' to buffer
0000128C  14FC 0042                429              MOVE.B  #$42, (A2)+     *'B' to buffer
00001290  14FC 0009                430              MOVE.B  #$9, (A2)+      *tab to buffer
00001294  4EB9 000013E2            431              JSR     GETEA
0000129A  14FC 002C                432              MOVE.B  #$2C, (A2)+     *',' to buffer
0000129E                           433              
0000129E  4EB9 00001504            434              JSR     SWAP2MOVE       * swap destination and source regs
000012A4  4EB9 000013E2            435              JSR     GETEA  
000012AA                           436  
000012AA                           437              
000012AA  4E75                     438              RTS
000012AC                           439  end0001
000012AC                           440  *===========================================================
000012AC                           441  
000012AC                           442  ************************************************************  
000012AC                           443  * Case for: 0010
000012AC                           444  * --(MOVE.L, MOVEA.L)
000012AC                           445  code0010:
000012AC                           446  *===========================================================
000012AC                           447  
000012AC                           448  ************************************************************  
000012AC                           449  * Case for: 0011
000012AC                           450  * --(MOVE.W, MOVEA.W)
000012AC                           451  code0011:
000012AC                           452  *===========================================================
000012AC                           453  
000012AC                           454  ************************************************************  
000012AC                           455  * Case for: 0100
000012AC                           456  * --(CLR,MOVEM,JMP,JSR,RTS,LEA) 
000012AC                           457  code0100:
000012AC                           458  
000012AC                           459  ************************************************************  
000012AC                           460  * Case for: 0101
000012AC                           461  * --BAD INSTRUCTION
000012AC                           462  code0101:
000012AC                           463  *===========================================================
000012AC                           464  
000012AC                           465  ************************************************************  
000012AC                           466  * Case for: 0110
000012AC                           467  * --(Bcc)
000012AC                           468  code0110:
000012AC                           469  *===========================================================
000012AC                           470  
000012AC                           471  ************************************************************  
000012AC                           472  * Case for: 0111
000012AC                           473  * --BAD INSTRUCTION
000012AC                           474  code0111:
000012AC                           475  *===========================================================
000012AC                           476  
000012AC                           477  ************************************************************  
000012AC                           478  * Case for: 1000
000012AC                           479  * --(OR) 
000012AC                           480  code1000:
000012AC                           481  *===========================================================
000012AC                           482  
000012AC                           483  ************************************************************  
000012AC                           484  * Case for: 1001
000012AC                           485  * --(SUB, SUBA)
000012AC                           486  code1001:
000012AC  14FC 0053                487              MOVE.B  #$53, (A2)+     *'S' to buffer
000012B0  14FC 0055                488              MOVE.B  #$55, (A2)+     *'U' to buffer
000012B4  14FC 0042                489              MOVE.B  #$42, (A2)+     *'B' to buffer
000012B8  4EB9 000014DE            490              JSR     GETSIZE         *get the instruction size (OPMODE)
000012BE  B63C 0003                491              CMP.B   #%11, D3        *11 = SUBA  
000012C2  6600 004A                492              BNE     subSub
000012C6  14FC 0041                493              MOVE.B  #$41, (A2)+     *'A' to buffer
000012CA  14FC 002E                494              MOVE.B  #$2E, (A2)+     *'.' to buffer
000012CE  3607                     495              MOVE.W  D7, D3          *move to utility
000012D0  E08B                     496              LSR.L   #8, D3          *shift for opmode
000012D2  0243 0001                497              ANDI.W  #$0001, D3      *isolate 8 to determine size
000012D6  B63C 0001                498              CMP.B   #%1, D3         *long?
000012DA  6700 0008                499              BEQ     subLong         *it's a longword
000012DE  4EF9 000012E8            500              JMP     subSuba
000012E4                           501  **SUBA******************************************************            
000012E4  14FC 004C                502  subLong     MOVE.B  #$4C, (A2)+     *'L' to buffer
000012E8  14FC 0020                503  subSuba     MOVE.B  #$20, (A2)+     *' ' to buffer    
000012EC  14FC 0020                504              MOVE.B  #$20, (A2)+     *' ' to buffer
000012F0  14FC 0020                505              MOVE.B  #$20, (A2)+     *' ' to buffer
000012F4  4EB9 000013E2            506              JSR     GETEA           *get effective address
000012FA  14FC 002C                507              MOVE.B  #$2C,(A2)+      *'B' to buffer
000012FE  14FC 0041                508              MOVE.B  #$41,(A2)+      *'B' to buffer
00001302  4EB9 000014E8            509              JSR     GETREGISTER     *get the register number
00001308  4EF9 00001358            510              JMP     end1001         *return
0000130E                           511  **SUB*EA>>Register****************************************** 
0000130E  14FC 002E                512  subSub      MOVE.B  #$2E, (A2)+     *'B' to buffer
00001312  4EB9 00001554            513              JSR     SIZE2BUFFER     *send size to buffer
00001318  14FC 0009                514              MOVE.B  #$09, (A2)+     *tab
0000131C  4EB9 000014FA            515              JSR     GETDIRECTION    *isolate bit for direction
00001322  B63C 0000                516              CMP.B   #%0, D3         *direction bit 0 = EA; 1 = regs
00001326  6600 001C                517              BNE     subSubR         
0000132A  4EB9 000013E2            518              JSR     GETEA           *get effective address
00001330  14FC 002C                519              MOVE.B  #$2C,(A2)+      *',' to buffer   
00001334  14FC 0044                520              MOVE.B  #$44,(A2)+      *'D' to buffer
00001338  4EB9 000014E8            521              JSR     GETREGISTER     *get the register number
0000133E  4EF9 00001358            522              JMP     end1001         *return
00001344                           523  **SUB*Register>>EA******************************************            
00001344  14FC 0044                524  subSubR     MOVE.B  #$44,(A2)+      *'D' to buffer
00001348  4EB9 000014E8            525              JSR     GETREGISTER     *get the register number
0000134E  14FC 002C                526              MOVE.B  #$2C,(A2)+      *',' to buffer
00001352  4EB9 000013E2            527              JSR     GETEA           *get effective address
00001358  4E75                     528  end1001     RTS                     *return
0000135A                           529  *===========================================================
0000135A                           530                                                         
0000135A                           531  ************************************************************  
0000135A                           532  * Case for: 1010
0000135A                           533  * --BAD INSTRUCTION
0000135A                           534  code1010:
0000135A                           535  *===========================================================
0000135A                           536  
0000135A                           537  ************************************************************  
0000135A                           538  * Case for: 1011
0000135A                           539  * --(CMP,CMPA)
0000135A                           540  code1011:
0000135A                           541  *===========================================================
0000135A                           542  
0000135A                           543  ************************************************************  
0000135A                           544  * Case for: 1100
0000135A                           545  * --(AND)
0000135A                           546  *MULU, EXG are not applicable to this assignment and will be 
0000135A                           547  *regarded as a bad instruction
0000135A                           548  code1100:
0000135A  3607                     549              MOVE.W  D7, D3          *move to utility
0000135C  EC8B                     550              LSR.L   #6, D3          *shift
0000135E  0243 0003                551              ANDI.W  #$3, D3         *isolate
00001362  B63C 0003                552              CMP.B   #$3, D3         *MULU/MULS?
00001366  6700 0314                553              BEQ     BADINST         *instruction not supported
0000136A                           554              
0000136A  3607                     555              MOVE.W  D7, D3          *move to utility
0000136C  E68B                     556              LSR.L   #3, D3          *shift
0000136E  0203 001F                557              ANDI.B  #$1F, D3        *isolate
00001372  B63C 0008                558              CMP.B   #$08, D3        *EXG?
00001376  6700 0304                559              BEQ     BADINST         *instruction not supported
0000137A  B63C 0009                560              CMP.B   #$09, D3        *EXG?
0000137E  6700 02FC                561              BEQ     BADINST         *instruction not supported
00001382  B63C 0011                562              CMP.B   #$11, D3        *EXG?
00001386  6700 02F4                563              BEQ     BADINST         *ok, phew made it to AND
0000138A                           564              
0000138A  14FC 0041                565              MOVE.B  #$41, (A2)+     *'A' to buffer
0000138E  14FC 004E                566              MOVE.B  #$4E, (A2)+     *'N' to buffer
00001392  14FC 0044                567              MOVE.B  #$44, (A2)+     *'D' to buffer
00001396  14FC 002E                568              MOVE.B  #$2E, (A2)+     *'.' to buffer
0000139A  4EB9 00001554            569              JSR     SIZE2BUFFER     *send size to buffer
000013A0  14FC 0009                570              MOVE.B  #$9, (A2)+      *tab
000013A4  4EB9 000014FA            571              JSR     GETDIRECTION    *isolate bit for direction
000013AA  B63C 0000                572              CMP.B   #%0, D3         *direction bit 0 = EA; 1 = regs
000013AE  6600 001C                573              BNE     andd01          *direction = 01
000013B2  4EB9 000013E2            574              JSR     GETEA           *get effective address
000013B8  14FC 002C                575              MOVE.B  #$2C, (A2)+     *',' to buffer
000013BC  14FC 0044                576              MOVE.B  #$44, (A2)+     *'D' to buffer
000013C0  4EB9 000014E8            577              JSR     GETREGISTER     *get the register number
000013C6  4EF9 000013E0            578              JMP     end1100     
000013CC                           579           
000013CC  14FC 0044                580  andd01      MOVE.B  #$44, (A2)+     *'D' to buffer
000013D0  4EB9 000014E8            581              JSR     GETREGISTER     *get the register number
000013D6  14FC 002C                582              MOVE.B  #$2C, (A2)+     *',' to buffer
000013DA  4EB9 000013E2            583              JSR     GETEA           *get effective address 
000013E0  4E75                     584  end1100     RTS                     *return
000013E2                           585  *===========================================================
000013E2                           586  
000013E2                           587  ************************************************************  
000013E2                           588  * Case for: 1101
000013E2                           589  * --(ADD,ADDA)
000013E2                           590  code1101:
000013E2                           591  *===========================================================
000013E2                           592  
000013E2                           593  ************************************************************  
000013E2                           594  * Case for: 1110
000013E2                           595  * --(ASR, LSL)
000013E2                           596  code1110:
000013E2                           597  *===========================================================
000013E2                           598  
000013E2                           599  ************************************************************  
000013E2                           600  * Case for: 1111
000013E2                           601  * --BAD INSTRUCTION
000013E2                           602  code1111:
000013E2                           603   *===========================================================             
000013E2                           604  
000013E2                           605  ************************************************************
000013E2                           606  *  _____ _____ _____ _____ ____ _____ _____     _______      _    ____  ____  ____  _____ ____ ____  
000013E2                           607  * | ____|  ___|  ___| ____/ ___|_   _|_ _\ \   / / ____|    / \  |  _ \|  _ \|  _ \| ____/ ___/ ___| 
000013E2                           608  * |  _| | |_  | |_  |  _|| |     | |  | | \ \ / /|  _|     / _ \ | | | | | | | |_) |  _| \___ \___ \ 
000013E2                           609  * | |___|  _| |  _| | |__| |___  | |  | |  \ V / | |___   / ___ \| |_| | |_| |  _ <| |___ ___) |__) |
000013E2                           610  * |_____|_|   |_|   |_____\____| |_| |___|  \_/  |_____| /_/   \_\____/|____/|_| \_\_____|____/____/ 
000013E2                           611  *                                                                                                   
000013E2                           612  *GETEA
000013E2                           613  *Description: Converts the opcode instruction EA
000013E2                           614  * 1001 0110 0100 0001
000013E2                           615  *             ^-----^
000013E2                           616  *Registers Used:
000013E2                           617  *For consistency, please utilize registers in the following way.
000013E2                           618  *
000013E2                           619  *D1 - utility register
000013E2                           620  *D3 - utility register
000013E2                           621  *D7 - copy of working address
000013E2                           622  *
000013E2                           623  *A2 - buffer address of decoded instruction
000013E2                           624  *A6 - jump table
000013E2                           625  ************************************************************
000013E2                           626  GETEA:
000013E2                           627              *MOVE.W  #$4541, (A2)+   *'EA' to buffer
000013E2                           628              *TODO
000013E2  4DF9 00001400            629              LEA     EA_TABLE, A6
000013E8  4283                     630              CLR.L   D3
000013EA  3607                     631              MOVE.W  D7, D3
000013EC  0243 003F                632              ANDI.W  #$003F, D3
000013F0  123C 0003                633              MOVE.B  #3, D1
000013F4  E26B                     634              LSR.W   D1, D3
000013F6  C6FC 0006                635              MULU    #6, D3
000013FA  4EB6 3000                636              JSR     0(A6, D3)
000013FE  4E75                     637              RTS                     *return
00001400                           638  *===========================================================
00001400                           639  
00001400                           640  ************************************************************
00001400                           641  *GET_TABLE
00001400                           642  *Description: Jump table of Effective Address Modes
00001400                           643  ************************************************************
00001400                           644  EA_TABLE:       
00001400  4EF9 00001430            645              JMP     eacode000
00001406  4EF9 00001442            646              JMP     eacode001
0000140C  4EF9 00001454            647              JMP     eacode010
00001412  4EF9 0000146E            648              JMP     eacode011
00001418  4EF9 0000148C            649              JMP     eacode100
0000141E  4EF9 000014AA            650              JMP     eacode101
00001424  4EF9 000014B0            651              JMP     eacode110
0000142A  4EF9 000014B6            652              JMP     eacode111
00001430                           653  *===========================================================
00001430                           654  
00001430                           655  ************************************************************
00001430                           656  *EA CODES
00001430                           657  *Description: Lsit of Effective Address Subrotines
00001430                           658  *000,001,010,011,100,101,110,111
00001430                           659  *Registers Used:
00001430                           660  *TODO
00001430                           661  *
00001430                           662  *Data Register**********************************************
00001430  3607                     663  eacode000   MOVE.W      D7, D3          *move to utility
00001432  0243 0007                664              ANDI.W      #$7, D3         *isolate
00001436  14FC 0044                665              MOVE.B      #$44,(A2)+      *'D' to buffer
0000143A  0603 0030                666              ADD.B       #$30, D3        *convert register number to ascii
0000143E  14C3                     667              MOVE.B      D3,(A2)+        *to buffer                  
00001440  4E75                     668  endea000    RTS                         *return
00001442                           669  
00001442                           670  *Address Register*******************************************
00001442  3607                     671  eacode001   MOVE.W      D7, D3          *move to utility
00001444  0243 0007                672              ANDI.W      #$7, D3         *isolate
00001448  163C 0041                673              MOVE.B      #$41, D3        *'A' to buffer
0000144C  0603 0030                674              ADD.B       #$30, D3        *convert register number to ascii
00001450  14C3                     675              MOVE.B      D3,(A2)+        *to buffer  
00001452  4E75                     676  endea001    RTS                         *return
00001454                           677  
00001454                           678  *Address
00001454  3607                     679  eacode010   MOVE.W      D7, D3          *move to utility
00001456  0243 0007                680              ANDI.W      #$7, D3         *isolate
0000145A  14FC 0028                681              MOVE.B      #$28,(A2)+      *'(' to buffer            
0000145E  14FC 0041                682              MOVE.B      #$41,(A2)+      *'A' to buffer
00001462  0603 0030                683              ADD.B       #$30, D3        *convert register number to ascii
00001466  14C3                     684              MOVE.B      D3,(A2)+        *to buffer  
00001468  14FC 0029                685              MOVE.B      #$29,(A2)+      *')' to buffe
0000146C  4E75                     686  endea010    RTS                         *return
0000146E                           687  
0000146E                           688  *Address with Postincrement*********************************
0000146E  3607                     689  eacode011   MOVE.W      D7, D3          *move to utility
00001470  0243 0007                690              ANDI.W      #$7, D3         *isolate
00001474  14FC 0028                691              MOVE.B      #$28,(A2)+      *'(' to buffer            
00001478  14FC 0041                692              MOVE.B      #$41,(A2)+      *'A' to buffer
0000147C  0603 0030                693              ADD.B       #$30, D3        *convert register number to ascii
00001480  14C3                     694              MOVE.B      D3,(A2)+        *to buffer  
00001482  14FC 0029                695              MOVE.B      #$29,(A2)+      *')' to buffer
00001486  14FC 002B                696              MOVE.B      #$2B, (A2)+     *'+' to buffer
0000148A  4E75                     697  endea011    RTS                         *return
0000148C                           698  
0000148C                           699  *Address with Predecrement**********************************
0000148C  3607                     700  eacode100   MOVE.W      D7, D3          *move to utility
0000148E  0243 0007                701              ANDI.W      #$7, D3         *isolate
00001492  14FC 002D                702              MOVE.B      #$2D,(A2)+      *'-' to buffer 
00001496  14FC 0028                703              MOVE.B      #$28,(A2)+      *'(' to buffer            
0000149A  14FC 0041                704              MOVE.B      #$41,(A2)+      *'A' to buffer
0000149E  0603 0030                705              ADD.B       #$30, D3        *convert register number to ascii
000014A2  14C3                     706              MOVE.B      D3,(A2)+        *to buffer  
000014A4  14FC 0029                707              MOVE.B      #$29,(A2)+      *')' to buffe
000014A8  4E75                     708  endea100    RTS                         *return
000014AA                           709  
000014AA                           710  *Bad Instruction********************************************
000014AA  4EF9 0000167C            711  eacode101   JMP         BADINST
000014B0                           712  
000014B0                           713  *Bad Instruction********************************************
000014B0  4EF9 0000167C            714  eacode110   JMP         BADINST
000014B6                           715  
000014B6                           716  *Immediate**************************************************
000014B6  4EB9 0000165C            717  eacode111   JSR         REGISTERBIT     *isolate register bits
000014BC  0C03 0000                718              CMPI.B      #$0, D3         *word?
000014C0  6700 010E                719              BEQ         WORD2BUFFER
000014C4  0C03 0001                720              CMPI.B      #$1, D3         *long?
000014C8  6700 0140                721              BEQ         LONG2BUFFER
000014CC  0C03 0002                722              CMPI.B      #$2, D3         *PC?
000014D0  6700 0192                723              BEQ         PC2BUFFER
000014D4  0C03 0004                724              CMPI.B      #$4, D3         *Immediate Data?
000014D8  6700 01A0                725              BEQ         IMM2BUFER
000014DC  4E75                     726  endea111    RTS                         *return
000014DE                           727  *===========================================================
000014DE                           728  
000014DE                           729  ************************************************************
000014DE                           730  *GETSIZE
000014DE                           731  *Description: Returns the size of the bit in the utility register
000014DE                           732  * 1001 0110 0100 0001
000014DE                           733  *       ^^--------->|
000014DE                           734  *Registers Used:
000014DE                           735  *D3 - size bit
000014DE                           736  *D7 - copy of instruction
000014DE                           737  ************************************************************
000014DE                           738  GETSIZE:
000014DE  3607                     739              MOVE.W  D7, D3          *move to utility
000014E0  EC4B                     740              LSR.W   #6, D3          *shift
000014E2  0243 0003                741              ANDI.W  #$0003, D3      *isolate
000014E6  4E75                     742  endGS       RTS                     *return
000014E8                           743  *===========================================================
000014E8                           744  
000014E8                           745  ************************************************************
000014E8                           746  *GETREGISTER
000014E8                           747  *Description: Finds the register size and sends it to the output buffer
000014E8                           748  * 1001 0110 0100 0001
000014E8                           749  *      ^-^--------->|
000014E8                           750  *Registers Used:
000014E8                           751  *D3 - size bit
000014E8                           752  *D7 - copy of instruction
000014E8                           753  *A2 - buffer address of decoded instruction          
000014E8                           754  ************************************************************
000014E8                           755  GETREGISTER:
000014E8  3607                     756              MOVE.W  D7,D3            *move to utility
000014EA  E08B                     757              LSR.L   #8,D3            *shift
000014EC  E28B                     758              LSR.L   #1,D3            *shift
000014EE  0203 0007                759              ANDI.B  #$7,D3           *isolate last 7 bits for register number
000014F2  0603 0030                760              ADD.B   #$30,D3          *convert register number to ascii
000014F6  14C3                     761              MOVE.B  D3,(A2)+         *to buffer
000014F8  4E75                     762  endGR       RTS                      *return
000014FA                           763  *===========================================================
000014FA                           764  
000014FA                           765  ************************************************************
000014FA                           766  *GETDIRECTION
000014FA                           767  *Description: Finds direction of the instruction and sets it to the utility register
000014FA                           768  * 1001 0110 0100 0001
000014FA                           769  *         ^-------->|
000014FA                           770  *Registers Used:
000014FA                           771  *D3 - size bit
000014FA                           772  *D7 - copy of instruction 
000014FA                           773  ************************************************************
000014FA                           774  GETDIRECTION:
000014FA  3607                     775              MOVE.W  D7, D3          *move to utility
000014FC  E08B                     776              LSR.L   #8, D3          *shift 8
000014FE  0203 0001                777              ANDI.B  #01, D3         *isolate 8th bit
00001502  4E75                     778  endgd       RTS                     *return
00001504                           779  *===========================================================
00001504                           780  
00001504                           781  ************************************************************
00001504                           782  *SWAP2MOVE
00001504                           783  *Description: For double EA move instructions, swaps registers to use EA jump table
00001504                           784  *Registers Used:
00001504                           785  *D3 - size bit
00001504                           786  *D4 - hold register for swap bits
00001504                           787  *D7 - swapped EA mode 
00001504                           788  SWAP2MOVE:
00001504  4283                     789              CLR.L   D3              *
00001506  3607                     790              MOVE.W  D7,D3           *move to utility
00001508  E04B                     791              LSR.W   #8,D3           *shift
0000150A  E24B                     792              LSR.W   #1,D3           *shift
0000150C  0243 0007                793              ANDI.W  #$0007,D3       *
00001510  8843                     794              OR.W    D3,D4           *store bits for swap
00001512  3607                     795              MOVE.W  D7,D3           *move to utility
00001514  E64B                     796              LSR.W   #3,D3           *shift bits 6-8 to normal ea position
00001516  8843                     797              OR.W    D3,D4           *
00001518  4EB9 00001522            798              JSR     s2mSize         *get mode size
0000151E  3E04                     799              MOVE.W  D4,D7           *load swap register
00001520  4E75                     800  ends2m      RTS                     *return
00001522                           801  
00001522  3607                     802  s2mSize     MOVE.W  D7,D3           *move to utility
00001524  E04B                     803              LSR.W   #8,D3           *shift
00001526  E84B                     804              LSR.W   #4,D3           *
00001528  0243 0003                805              ANDI.W  #$0003,D3       *isolate
0000152C  B63C 0001                806              CMP.B   #$1,D3          *byte?
00001530  6700 0020                807              BEQ     ends2mS         *yes
00001534  B63C 0002                808              CMP.B   #$2,D3          *long?
00001538  6700 0014                809              BEQ     s2mL            *yes
0000153C  B63C 0003                810              CMP.B   #$3,D3          *word?
00001540  6600 013A                811              BNE     BADINST         *No? bad instrustion        
00001544  0044 0040                812  s2mW        ORI.W   #$0040,D4       *add size
00001548  4EF9 00001552            813              JMP     ends2mS         *
0000154E  0044 0080                814  s2mL        ORI.W   #$0080,D4       *add size
00001552  4E75                     815  ends2mS     RTS                     *return
00001554                           816  *===========================================================
00001554                           817  
00001554                           818  ************************************************************
00001554                           819  *  ____  _   _ _____ _____ _____ ____     ____ ___  _   ___     _______ ____ _____ 
00001554                           820  * | __ )| | | |  ___|  ___| ____|  _ \   / ___/ _ \| \ | \ \   / / ____|  _ \_   _|
00001554                           821  * |  _ \| | | | |_  | |_  |  _| | |_) | | |  | | | |  \| |\ \ / /|  _| | |_) || |  
00001554                           822  * | |_) | |_| |  _| |  _| | |___|  _ <  | |__| |_| | |\  | \ V / | |___|  _ < | |  
00001554                           823  * |____/ \___/|_|   |_|   |_____|_| \_\  \____\___/|_| \_|  \_/  |_____|_| \_\|_|  
00001554                           824  *
00001554                           825  *BUFFER SUBROUTINES                                                                                 
00001554                           826  *Description: Puts word to print buffer
00001554                           827  *D3 - Utility register
00001554                           828  *D6 - Counter
00001554                           829  *A0 - Utility address
00001554                           830  *A2 - Address buffer
00001554                           831  *----------------------------------------------------------- 
00001554                           832  
00001554                           833  ************************************************************
00001554                           834  *SIZE2BUFFER
00001554                           835  *Description: Isolates and converts the instruction size and sends it to the output buffer
00001554                           836  *              Byte, word, long read word in memory for instructions that utilize immediate
00001554                           837  *              data.  At the end of the instruction, the working memory address is advanced.
00001554                           838  *Registers Used:
00001554                           839  *D3 - size bit
00001554                           840  *A2 - buffer address of decoded instruction
00001554                           841  ************************************************************
00001554                           842  SIZE2BUFFER:
00001554  4EB8 14DE                843              JSR     GETSIZE         *get the size of bit
00001558  B63C 0000                844              CMP.B   #%00, D3        *byte
0000155C  6700 001E                845              BEQ     s2bB        
00001560  B63C 0001                846              CMP.B   #%01, D3        *word
00001564  6700 0020                847              BEQ     s2bW        
00001568  B63C 0002                848              CMP.B   #%10, D3        *long
0000156C  6700 0022                849              BEQ     s2bL        
00001570  4EB9 0000167C            850              JSR     BADINST         *bad instruction
00001576  4EF9 00001594            851              JMP     ends2b      
0000157C                           852              
0000157C  14FC 0042                853  s2bB        MOVE.B  #$42,(A2)+      *'B' to buffer
00001580  4EF9 00001594            854              JMP     ends2b      
00001586  14FC 0057                855  s2bW        MOVE.B  #$57,(A2)+      *'W' to buffer
0000158A  4EF9 00001594            856              JMP     ends2b    
00001590  14FC 004C                857  s2bL        MOVE.B  #$4C,(A2)+      *'L' to buffer
00001594  4E75                     858  ends2b      RTS                     *return
00001596                           859  *===========================================================
00001596                           860  
00001596                           861  ************************************************************
00001596                           862  *BYTE2BUFFER
00001596                           863  *Description: Converts byte and sends it to the output buffer
00001596                           864  *Buffer: $XX
00001596                           865  ************************************************************
00001596                           866  BYTE2BUFFER:
00001596  48E7 FE00                867              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
0000159A  14FC 0024                868              MOVE.B      #'$', (A2)+  
0000159E  4284                     869              CLR.L       D4                  *clear counter
000015A0  2E88                     870              MOVE.L      A0, (A7)
000015A2  2E17                     871              MOVE.L      (A7), D7
000015A4  2417                     872              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
000015A6  183C 0002                873              MOVE.B      #2, D4              *load counter
000015AA                           874  
000015AA                           875  b2bLoop                 
000015AA  B83C 0000                876              CMP.B       #$00, D4            *compare counter with 0
000015AE  6700 0016                877              BEQ         endb2b              *if zero, return
000015B2  E95A                     878              ROL.W       #4, D2              *roll the bits in D2 to the left
000015B4  3602                     879              MOVE.W      D2, D3              *move rolled bits into temp storage
000015B6  0243 000F                880              ANDI.W      #$000F, D3          *and the bits to isolate ascii char   
000015BA  4EB9 00001644            881              JSR         HEX2ASCII           *load ascii char into buffer            
000015C0  5304                     882              SUBQ.B      #$1, D4             *subtract from counter
000015C2  4EF8 15AA                883              JMP         b2bLoop             *keep looping until counter hits zero
000015C6                           884              
000015C6  3607                     885  endb2b      MOVE.W      D7, D3              *re-load current word for temp storage            
000015C8  5448                     886              ADDQ.W      #2, A0              *advancing memory pointer by word  
000015CA  4CDF 007F                887              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
000015CE  4E75                     888              RTS                             *return
000015D0                           889  *===========================================================
000015D0                           890  
000015D0                           891  ************************************************************
000015D0                           892  *WORD2BUFFER
000015D0                           893  *Buffer: $XXXX
000015D0                           894  ************************************************************
000015D0                           895  WORD2BUFFER:
000015D0  48E7 FE00                896              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
000015D4  14FC 0024                897              MOVE.B      #'$', (A2)+  
000015D8  4284                     898              CLR.L       D4                  *clear counter
000015DA  2E88                     899              MOVE.L      A0, (A7)
000015DC  2E17                     900              MOVE.L      (A7), D7
000015DE  2417                     901              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
000015E0  183C 0004                902              MOVE.B      #4, D4              *load counter
000015E4                           903  
000015E4                           904  w2bLoop                 
000015E4  B83C 0000                905              CMP.B       #$00, D4            *compare counter with 0
000015E8  6700 0016                906              BEQ         endw2b              *if zero, return
000015EC  E95A                     907              ROL.W       #4, D2              *roll the bits in D2 to the left
000015EE  3602                     908              MOVE.W      D2, D3              *move rolled bits into temp storage
000015F0  0243 000F                909              ANDI.W      #$000F, D3          *and the bits to isolate ascii char   
000015F4  4EB9 00001644            910              JSR         HEX2ASCII           *load ascii char into buffer            
000015FA  5304                     911              SUBQ.B      #$1, D4             *subtract from counter
000015FC  4EF8 15E4                912              JMP         w2bLoop             *keep looping until counter hits zero
00001600                           913              
00001600  3607                     914  endw2b      MOVE.W      D7, D3              *re-load current word for temp storage            
00001602  5448                     915              ADDQ.W      #2, A0              *advancing memory pointer by word  
00001604  4CDF 007F                916              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
00001608  4E75                     917              RTS                             *return
0000160A                           918  *===========================================================
0000160A                           919   
0000160A                           920  ************************************************************
0000160A                           921  *LONG2BUFFER
0000160A                           922  *Buffer: $XXXXXXXX
0000160A                           923  ************************************************************           
0000160A                           924  LONG2BUFFER:
0000160A  48E7 FE00                925              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
0000160E  14FC 0024                926              MOVE.B      #'$', (A2)+  
00001612  4284                     927              CLR.L       D4                  *clear counter
00001614  2E88                     928              MOVE.L      A0, (A7)
00001616  2E17                     929              MOVE.L      (A7), D7
00001618  2417                     930              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
0000161A  183C 0008                931              MOVE.B      #8, D4              *load counter
0000161E                           932  
0000161E                           933  l2bLoop                 
0000161E  B83C 0000                934              CMP.B       #$00, D4            *compare counter with 0
00001622  6700 0016                935              BEQ         endl2b              *if 0, return
00001626  E95A                     936              ROL.W       #4, D2              *
00001628  3602                     937              MOVE.W      D2, D3              *
0000162A  0243 000F                938              ANDI.W      #$000F, D3          *isolate
0000162E  4EB9 00001644            939              JSR         HEX2ASCII           *to buffer           
00001634  5304                     940              SUBQ.B      #$1, D4             *subtract from counter
00001636  4EF8 161E                941              JMP         l2bLoop             *loop
0000163A                           942              
0000163A  3607                     943  endl2b      MOVE.W      D7, D3              *load from utility           
0000163C  5848                     944              ADDQ.W      #4, A0              *advancing memory pointer by word  
0000163E  4CDF 007F                945              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
00001642  4E75                     946              RTS  
00001644                           947  *===========================================================
00001644                           948   
00001644                           949  ************************************************************
00001644                           950  *HEX2ASCII
00001644                           951  *Description: Converts bit to ASCII and send to buffer
00001644                           952  ************************************************************            
00001644                           953  HEX2ASCII:  
00001644  B63C 000A                954              CMP.B       #$A, D3             * Confirm hex character?
00001648  6C00 000A                955              BGE         letter              * Is it a letter or number?
0000164C  0603 0030                956  number      ADDI.B      #$30,D3             * Convert decimal to ASCII
00001650  6000 0006                957              BRA         write2Buff          * save to good buffer
00001654  0603 0037                958  letter      ADDI.B      #$37,D3
00001658  14C3                     959  write2buff  MOVE.B      D3,(A2)+
0000165A  4E75                     960  endh2a      RTS
0000165C                           961  *===========================================================   
0000165C                           962  
0000165C                           963  ************************************************************
0000165C                           964  *REGISTERBIT
0000165C                           965  *Description: Converts register bit and sends to buffer
0000165C                           966  ************************************************************ 
0000165C                           967  REGISTERBIT:
0000165C  3607                     968              MOVE.W  D7, D3
0000165E  0243 0007                969              ANDI.W  #$07, D3
00001662  4E75                     970  endrb       RTS
00001664                           971  *===========================================================
00001664                           972  
00001664                           973  ************************************************************
00001664                           974  *PC2BUFFER - NO NEED?
00001664                           975  *Description: 
00001664                           976  ************************************************************ 
00001664                           977  PC2BUFFER:
00001664  4EB8 15D0                978              JSR     WORD2BUFFER
00001668  14FC 0028                979              MOVE.B      #$28,(A2)+   *'(' to buffer            
0000166C  14FC 0050                980              MOVE.B      #$50,(A2)+   *'P' to buffer
00001670  14FC 0043                981              MOVE.B      #$43,(A2)+   *'C' to buffer
00001674  14FC 0029                982              MOVE.B      #$29,(A2)+   *')' to buffer                        
00001678  4E75                     983  endpc2b     RTS
0000167A                           984  *===========================================================
0000167A                           985             
0000167A                           986  ************************************************************
0000167A                           987  *IMM2BUFER
0000167A                           988  *Description: Converts immediate data and sends to buffer
0000167A                           989  ************************************************************ 
0000167A                           990  IMM2BUFER:
0000167A                           991              
0000167A  4E75                     992  endi2b      RTS
0000167C                           993  *===========================================================        
0000167C                           994  
0000167C                           995  ************************************************************
0000167C                           996  *BADINST
0000167C                           997  *Description: A bad instruction has been called, print to console
0000167C                           998  *Registers Used:
0000167C                           999  *D5 - flag condition
0000167C                          1000  *A2 - buffer address of decoded instruction
0000167C                          1001  *A2 - working address    
0000167C                          1002  ************************************************************
0000167C                          1003  BADINST:
0000167C  1A3C 0001               1004              MOVE.B  #1,D5           *set bad flag
00001680  244B                    1005              MOVEA.L A3, A2          *reset the buffer pointer 
00001682  14FC 0044               1006              MOVE.B  #$44,(A2)+      *'D' to buffer
00001686  14FC 0041               1007              MOVE.B  #$41,(A2)+      *'A' to buffer
0000168A  14FC 0054               1008              MOVE.B  #$54,(A2)+      *'T' to buffer
0000168E  14FC 0041               1009              MOVE.B  #$41,(A2)+      *'A' to buffer
00001692  14FC 0009               1010              MOVE.B  #$09,(A2)+      *tab
00001696  14FC 0024               1011              MOVE.B  #$24,(A2)+      *'$' to buffer     
0000169A                          1012              *JSR     getBadWord     *add bad word to buffer TODO
0000169A  4E75                    1013  endbadinst  RTS                     *return
0000169C                          1014  *===========================================================
0000169C                          1015  
0000169C                          1016  
0000169C                          1017  ************************************************************
0000169C                          1018  *  _____ _   _ ____      ____ ___ __  __ 
0000169C                          1019  * | ____| \ | |  _ \    / ___|_ _|  \/  |
0000169C                          1020  * |  _| |  \| | | | |   \___ \| || |\/| |
0000169C                          1021  * | |___| |\  | |_| |    ___) | || |  | |
0000169C                          1022  * |_____|_| \_|____/    |____/___|_|  |_|
0000169C                          1023  *                                       
0000169C                          1024  *END
0000169C                          1025  *Description: Ends program
0000169C                          1026  ************************************************************          
0000169C                          1027  END:
0000169C  FFFF FFFF               1028              SIMHALT              
000016A0                          1029  *===========================================================
000016A0                          1030           
000016A0                          1031  *-----------------------------------------------------------
000016A0                          1032  *variables
000016A0                          1033  *-----------------------------------------------------------
000016A0= 45 61 73 79 36 38 ...   1034  intro       dc.b    'Easy68k Disassembler',0,CR,LF
000016B8= 0018                    1035  i_length    dc.w    i_length-intro
000016BA                          1036  
000016BA= 45 6E 74 65 72 20 ...   1037  srt_addr    dc.b    'Enter starting address: $',0
000016D4= 001A                    1038  s_len       dc.w    s_len-srt_addr
000016D6                          1039  
000016D6= 45 6E 74 65 72 20 ...   1040  end_addr    dc.b    'Enter ending address: $',0
000016EE= 0018                    1041  e_len       dc.w    e_len-end_addr
000016F0                          1042  
000016F0= 54 68 65 20 73 74 ...   1043  t_str_start dc.b    'The start address is: $',0
00001708= 0018                    1044  t_start     dc.w    t_start-t_str_start
0000170A                          1045  
0000170A= 54 68 65 20 65 6E ...   1046  t_str_end   dc.b    'The end address is: $',0
00001720= 0016                    1047  t_end       dc.w    t_end-t_str_end
00001722                          1048  
00001722= 45 72 72 6F 72 3A ...   1049  str_error   dc.b    'Error: starting or ending address has error',0
0000174E= 002C                    1050  err_len     dc.w    err_len-str_error 
00001750                          1051  
00001750= 50 72 65 73 73 20 ...   1052  str_cont    dc.b    'Press enter to continue.',0
0000176A= 001A                    1053  cont_len    dc.w    cont_len-str_cont
0000176C                          1054  
0000176C= 00                      1055  str_cr      dc.b    '',0
0000176E= 0002                    1056  cr_len      dc.w    cr_len-str_cr
00001770                          1057  
00001770= 01                      1058  buffer      dc.b    1
00001771                          1059  print_stack ds.b    8
00001779                          1060  
0000177A                          1061  v_srt_add   ds.l    1               *store start address
0000177E                          1062  v_end_add   ds.l    1               *store end address
00001782                          1063  v_test      ds.l    1               *start a temp value
00001786                          1064  
00001786                          1065  
00001786                          1066      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ANDD01              13CC
ASCII2HEX           1128
B2BLOOP             15AA
BADFLAG             0
BADINST             167C
BUF                 9000
BUFFER              1770
BUFFER_FILL         11F2
BUFFER_PREP         11C4
BYTE2BUFFER         1596
CLEAR               10A6
CODE0000            1272
CODE0001            1278
CODE0010            12AC
CODE0011            12AC
CODE0100            12AC
CODE0101            12AC
CODE0110            12AC
CODE0111            12AC
CODE1000            12AC
CODE1001            12AC
CODE1010            135A
CODE1011            135A
CODE1100            135A
CODE1101            13E2
CODE1110            13E2
CODE1111            13E2
CONT_LEN            176A
CR                  D
CR_LEN              176E
DIS_BADINPUT        1058
DIS_CONT            1086
DIS_CR              1072
DIS_INTRO_MSG       1044
EACODE000           1430
EACODE001           1442
EACODE010           1454
EACODE011           146E
EACODE100           148C
EACODE101           14AA
EACODE110           14B0
EACODE111           14B6
EA_TABLE            1400
END                 169C
END0001             12AC
END1001             1358
END1100             13E0
ENDA2H              11B8
ENDB2B              15C6
ENDBADINST          169A
ENDBF               11F8
ENDBI               106E
ENDBP               11DE
ENDCLEAR            10B6
ENDDC               10A4
ENDEA000            1440
ENDEA001            1452
ENDEA010            146C
ENDEA011            148A
ENDEA100            14A8
ENDEA111            14DC
ENDGD               1502
ENDGOP              1210
ENDGR               14F8
ENDGS               14E6
ENDH2A              165A
ENDI2B              167A
ENDINPUT            1126
ENDINTRO            1056
ENDL2B              163A
ENDPC2B             1678
ENDRB               1662
ENDS2B              1594
ENDS2M              1520
ENDS2MS             1552
ENDW2B              1600
END_ADDR            16D6
END_CR              1084
END_PI              11F0
ERROR               1196
ERR_LEN             174E
E_LEN               16EE
GETDIRECTION        14FA
GETEA               13E2
GETOPCODE           11FA
GETREGISTER         14E8
GETSIZE             14DE
GOODFLAG            1
HEX2ASCII           1644
IMM2BUFER           167A
INTRO               16A0
I_LENGTH            16B8
L2BLOOP             161E
LENGTH              0
LETTER              1654
LF                  A
LONG2BUFFER         160A
LOOP                1138
LOWER2HEX           118A
MAIN                1004
MAIN_CONT           1036
MAIN_END            1040
MAIN_INPUT          1016
MAIN_LOOP           1022
MAXADD              FFFFFF
MINADD              0
NUM2HEX             1172
NUMBER              164C
OP_TABLE            1212
PC2BUFFER           1664
PRINTBP             11D6
PRINTCOUNT          A
PRINTINST           11E0
PRINT_STACK         1771
REGISTERBIT         165C
RESUME              11A0
S2BB                157C
S2BL                1590
S2BW                1586
S2ML                154E
S2MSIZE             1522
S2MW                1544
SIZE2BUFFER         1554
SRT_ADDR            16BA
STACK               A000
START               1000
STR_CONT            1750
STR_CR              176C
STR_ERROR           1722
SUBLONG             12E4
SUBSUB              130E
SUBSUBA             12E8
SUBSUBR             1344
SWAP2MOVE           1504
S_LEN               16D4
TASK0               0
TASK1               1
TASK13              D
TASK14              E
TASK2               2
TASK3               3
T_END               1720
T_START             1708
T_STR_END           170A
T_STR_START         16F0
UPPER2HEX           117E
U_INPUT             10B8
V_END_ADD           177E
V_SRT_ADD           177A
V_TEST              1782
W2BLOOP             15E4
WORD2BUFFER         15D0
WRITE2BUFF          1658
