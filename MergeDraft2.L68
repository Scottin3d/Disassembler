00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/4/2020 3:49:27 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Scott Shirley, Carl Howing
00000000                             4  * Date       : June 6, 2020
00000000                             5  * Description: 
00000000                             6  ************************************************************
00000000                             7  
00000000                             8  ************************************************************
00000000                             9  *  ____            _     _                
00000000                            10  * |  _ \ ___  __ _(_)___| |_ ___ _ __ ___ 
00000000                            11  * | |_) / _ \/ _` | / __| __/ _ \ '__/ __|
00000000                            12  * |  _ <  __/ (_| | \__ \ ||  __/ |  \__ \
00000000                            13  * |_| \_\___|\__, |_|___/\__\___|_|  |___/
00000000                            14  *            |___/                        
00000000                            15  *Register Use
00000000                            16  *For consistency, please utilize registers in the following way.
00000000                            17  *
00000000                            18  *D0 -
00000000                            19  *D1 -
00000000                            20  *D2 - 
00000000                            21  *D3 - utility register
00000000                            22  *D4 -
00000000                            23  *D5 - flag condition
00000000                            24  *D6 - counter
00000000                            25  *D7 - copy of working address
00000000                            26  *
00000000                            27  *A0 - temp address holder
00000000                            28  *A1 - trap address
00000000                            29  *A2 - buffer address of decoded instruction
00000000                            30  *A3 -.
00000000                            31  *A4 - starting address
00000000                            32  *A5 - ending address
00000000                            33  *A6 -
00000000                            34  *A7 -
00000000                            35  ************************************************************
00000000                            36  
00000000                            37  ************************************************************
00000000                            38  * __     __         _       _     _                               _     _____ ___  _   _ 
00000000                            39  * \ \   / /_ _ _ __(_) __ _| |__ | | ___  ___      __ _ _ __   __| |   | ____/ _ \| | | |
00000000                            40  *  \ \ / / _` | '__| |/ _` | '_ \| |/ _ \/ __|    / _` | '_ \ / _` |   |  _|| | | | | | |
00000000                            41  *   \ V / (_| | |  | | (_| | |_) | |  __/\__ \   | (_| | | | | (_| |   | |__| |_| | |_| |
00000000                            42  *    \_/ \__,_|_|  |_|\__,_|_.__/|_|\___||___/    \__,_|_| |_|\__,_|   |_____\__\_\\___/ 
00000000                            43  *                                                                                        
00000000                            44  * Variables and EQUs
00000000                            45  ************************************************************
00000000  =00001000                 46  start       EQU     $1000               *start address
00000000  =0000A000                 47  stack       EQU     $A000               *stack address  
00000000  =00009000                 48  buf         EQU     $9000
00000000                            49  
00000000  =00000000                 50  minAdd      EQU     $00000000           *start of address space
00000000  =00FFFFFF                 51  maxAdd      EQU     $00FFFFFF           *end of address space
00000000                            52  
00000000  =0000000D                 53  CR          EQU     $0D                 *carriage return
00000000  =0000000A                 54  LF          EQU     $0A                 *line feed
00000000                            55  
00000000  =00000001                 56  goodflag    EQU     1                   *good flag condition
00000000  =00000000                 57  badflag     EQU     0                   *bad flag condition
00000000  =00000000                 58  length      EQU     0                   *
00000000                            59  
00000000  =0000000A                 60  printCount  EQU     10                  *number of lines printed to console before user input
00000000                            61  
00000000                            62  *TRAP tasks for preload
00000000  =00000000                 63  task0       EQU     00                  *Display string at (A1), D1.W bytes long (max 255) with carriage return and line feed (CR, LF)
00000000  =00000001                 64  task1       EQU     01                  *Display string at (A1), D1.W bytes long (max 255) without CR, LF
00000000  =00000002                 65  task2       EQU     02                  *Read string from keyboard and store at (A1), NULL terminated, length retuned in D1.W (max 80)
00000000  =00000003                 66  task3       EQU     03                  *Display signed number in D1.L in decimal in smallest field
00000000  =0000000D                 67  task13      EQU     13                  *Display the NULL terminated string at (A1) with CR, LF
00000000  =0000000E                 68  task14      EQU     14                  *Display the NULL terminated string at (A1) without CR, LF
00000000                            69  ************************************************************
00000000                            70  
00000000                            71  ************************************************************
00000000                            72  *  __  __       _       
00000000                            73  * |  \/  | __ _(_)_ __  
00000000                            74  * | |\/| |/ _` | | '_ \ 
00000000                            75  * | |  | | (_| | | | | |
00000000                            76  * |_|  |_|\__,_|_|_| |_|
00000000                            77  *                      
00000000                            78  ************************************************************
00001000                            79              ORG     start
00001000  6100 0042                 80              BSR     dis_intro_msg       *print intro message
00001004                            81              
00001004                            82              
00001004  6100 00A0                 83  main        BSR     CLEAR               *clear all registers
00001008  4FF9 0000A000             84              LEA     stack, SP           *load stack pointer
0000100E  45F9 00009000             85              LEA     buf, A2          *set buffer for input
00001014  2C4A                      86              MOVEA.L A2,A6 
00001016                            87              
00001016                            88              
00001016  6100 00A0                 89  main_input  BSR     U_INPUT             *branch to input
0000101A  BA3C 0000                 90              CMP.B   #$0, D5             *check if bad input
0000101E  6700 0038                 91              BEQ     dis_badInput        *bad flag, reinput 
00001022                            92                          
00001022  4EB9 000011C4             93  main_loop   JSR     BUFFER_PREP         *prep buffer
00001028                            94  
00001028                            95  *loop checking      
00001028  BBC8                      96              CMPA.L  A0, A5              * have we reached the end of our address range?
0000102A  6F00 0014                 97              BLE     main_end  
0000102E                            98   
0000102E  5246                      99              ADDI    #1, D6              *add counter
00001030  BC7C 000A                100              CMP     #printcount, D6     *check loop progress
00001034  66EC                     101              BNE     main_loop
00001036                           102                
00001036                           103              
00001036                           104  
00001036  4EB9 00001086            105  main_cont   JSR     dis_cont
0000103C  4EF8 1022                106              JMP     main_loop
00001040                           107  
00001040  6100 08E6                108  main_end    BSR     END
00001044                           109  *===========================================================
00001044                           110  
00001044                           111  *-----------------------------------------------------------
00001044                           112  *display subroutines
00001044                           113  *intro message, bad inputs, carriage return, enter2return, input test
00001044                           114  *-----------------------------------------------------------
00001044                           115  *intro message display
00001044                           116  ************************************************************
00001044                           117  dis_intro_msg
00001044  103C 000D                118              MOVE.B  #13,D0              *load task
00001048  43F9 0000192C            119              LEA     intro,A1            *load string
0000104E  3239 00001F3C            120              MOVE.W  i_length,D1         *load string length 
00001054  4E4F                     121              TRAP    #15                 *display
00001056  4E75                     122  endIntro    RTS                         *return
00001058                           123  
00001058                           124  *bad input error message display
00001058                           125  ************************************************************
00001058                           126  dis_badInput
00001058  103C 0000                127              MOVE.B  #task0,D0           *load task
0000105C  43F9 00001FA6            128              LEA     str_error, A1       *load string
00001062  3239 00001FD2            129              MOVE.W  err_len, D1         *load string length
00001068  4E4F                     130              TRAP    #15                 *display
0000106A  1A3C 0000                131              MOVE.B  #badFlag,D5         *set flag condition to bad
0000106E  4EB8 1016                132  endBI       JSR     main_input          *return to main_input
00001072                           133  
00001072                           134  *dsiplay carriage return
00001072                           135  ************************************************************
00001072                           136  dis_cr
00001072  103C 000D                137              MOVE.B  #task13, D0         *load task
00001076  43F9 00001FF0            138              LEA     str_cr, A1          *load string
0000107C  3239 00001FF2            139              MOVE.W  cr_len, D1          *load string length
00001082  4E4F                     140              TRAP    #15                 *display
00001084  4E75                     141  end_cr      RTS                         *return
00001086                           142  
00001086                           143  *enter2return
00001086                           144  ************************************************************
00001086                           145  dis_cont   
00001086  103C 000E                146              MOVE.B  #task14, D0         *load task
0000108A  43F9 00001FD4            147              LEA     str_cont, A1        *load string
00001090  3239 00001FEE            148              MOVE.W  cont_len, D1        *load string length
00001096  4E4F                     149              TRAP    #15                 *display
00001098                           150              
00001098  103C 0002                151              MOVE.B  #task2,D0           *load task
0000109C  4E4F                     152              TRAP    #15                 *get input
0000109E                           153              
0000109E  12BC 0050                154              MOVE.B  #$50,(A1)           *reset A1
000010A2                           155              
000010A2  4246                     156              CLR     D6                  *clear counter, reset loop
000010A4  4E75                     157  endDC       RTS                         *return
000010A6                           158  *===========================================================
000010A6                           159  
000010A6                           160  ************************************************************ 
000010A6                           161  *  _   _ _____ _     ____  _____ ____  
000010A6                           162  * | | | | ____| |   |  _ \| ____|  _ \ 
000010A6                           163  * | |_| |  _| | |   | |_) |  _| | |_) |
000010A6                           164  * |  _  | |___| |___|  __/| |___|  _ < 
000010A6                           165  * |_| |_|_____|_____|_|   |_____|_| \_\
000010A6                           166  *                                      
000010A6                           167  *HELPER SUBROUTINES
000010A6                           168  *Description: These subroutines are called during teh opcode translation
000010A6                           169  ************************************************************
000010A6                           170  
000010A6                           171  ************************************************************   
000010A6                           172  *CLEAR
000010A6                           173  *Description: Clears registers of values
000010A6                           174  ************************************************************        
000010A6                           175  CLEAR:
000010A6  4240                     176              CLR     D0
000010A8  4241                     177              CLR     D1
000010AA  4242                     178              CLR     D2
000010AC  4243                     179              CLR     D3
000010AE  4244                     180              CLR     D4
000010B0  4245                     181              CLR     D5
000010B2  4246                     182              CLR     D6
000010B4  4247                     183              CLR     D7
000010B6  4E75                     184  endClear    RTS
000010B8                           185  *===========================================================
000010B8                           186  
000010B8                           187  ************************************************************
000010B8                           188  *U_INPUT
000010B8                           189  *Description: Gets input address from user for program
000010B8                           190  *D5 - Return Status
000010B8                           191  *D7 - Temparary register to store address value
000010B8                           192  *A0 - Working Address
000010B8                           193  *A4 - Start Address
000010B8                           194  *A5 - End Address
000010B8                           195  ************************************************************
000010B8                           196  U_INPUT:
000010B8  103C 0001                197              MOVE.B  #task1,D0           *
000010BC  43F9 00001F3E            198              LEA     srt_addr,A1         *
000010C2  3239 00001F58            199              MOVE.W  s_len,D1            *
000010C8  4E4F                     200              TRAP    #15                 *
000010CA  D3FC 00001F58            201              ADDA.L  #s_len,A1           *
000010D0  103C 0002                202              MOVE.B  #task2,D0           *
000010D4  4E4F                     203              TRAP    #15                 *
000010D6  4EB9 00001128            204              JSR     ASCII2HEX
000010DC  BA3C 0000                205              CMP.B   #$00,D5             *bad input?
000010E0  6700 0044                206              BEQ     endInput
000010E4  23C7 00001FFE            207              MOVE.L  D7, v_srt_add       *store to varable
000010EA  4247                     208              CLR     D7
000010EC                           209              
000010EC  2848                     210              MOVEA.L A0,A4       
000010EE  103C 0001                211              MOVE.B  #task1,D0
000010F2  43F9 00001F5A            212              LEA     end_addr,A1
000010F8  3239 00001F72            213              MOVE.W  e_len,D1         
000010FE  4E4F                     214              TRAP    #15         
00001100  D3FC 00001F72            215              ADDA.L  #e_len,A1
00001106  103C 0002                216              MOVE.B  #task2,D0
0000110A  4E4F                     217              TRAP    #15
0000110C  4EB9 00001128            218              JSR     ASCII2HEX
00001112  BA3C 0000                219              CMP.B   #$00,D5             *bad input?
00001116  6700 000E                220              BEQ     endInput
0000111A  23C7 00002002            221              MOVE.L  D7, v_end_add        *store to varable
00001120  4247                     222              CLR     D7
00001122                           223  
00001122                           224  
00001122  2A48                     225              MOVEA.L A0,A5               *store ending to A5
00001124  204C                     226              MOVEA.L A4,A0               *store starting in A0  
00001126                           227                    
00001126  4E75                     228  endInput    RTS
00001128                           229  *===========================================================
00001128                           230  
00001128                           231  ************************************************************
00001128                           232  *ASCII2HEX 
00001128                           233  *Description: Converts an ASCII character to HEX - see flowchart for logic
00001128                           234  *D3 - Placeholder for current ascii byte
00001128                           235  *D4 - Translated address
00001128                           236  *D5 - Return status
00001128                           237  *D6 - Counter (6)
00001128                           238  *D7 - Temparary register to store address value
00001128                           239  *A0 - Stored address at end of subroutine
00001128                           240  ************************************************************
00001128                           241  ASCII2HEX:
00001128                           242              
00001128  48E7 F800                243              MOVEM.L D0-D4,-(SP)         *save data registers to the stack
0000112C  4EB8 10A6                244              JSR     CLEAR
00001130  1A3C 0001                245              MOVE.B  #$01,D5             *preset flag condition to good
00001134  3C3C 0000                246              MOVE    #length,D6
00001138                           247  
00001138                           248  loop
00001138  1619                     249              MOVE.B  (A1)+,D3            *
0000113A  B63C 0030                250              CMP.B   #$30,D3             *byte < 30??
0000113E  6D00 0056                251              BLT     error               *
00001142                           252              
00001142  B63C 003A                253              CMP.B   #$3A,D3             *byte < 3A??
00001146  6D00 002A                254              BLT     num2hex             *
0000114A                           255              
0000114A  B63C 0041                256              CMP.B   #$41,D3             *byte < 41??
0000114E  6D00 0046                257              BLT     error               *
00001152                           258              
00001152  B63C 0047                259              CMP.B   #$47,D3             *byte < 47?
00001156  6D00 0026                260              BLT     upper2hex           *
0000115A                           261              
0000115A  B63C 0061                262              CMP.B   #$61,D3             *byte < 61??
0000115E  6D00 0036                263              BLT     error               *
00001162                           264              
00001162  B63C 0067                265              CMP.B   #$67,D3             *byte < 67??
00001166  6D00 0022                266              BLT     lower2hex           *
0000116A                           267              
0000116A  B63C 0066                268              CMP.B   #$66,D3             *byte > 66??
0000116E  6E00 0026                269              BGT     error               *
00001172                           270  
00001172                           271  num2hex
00001172  0403 0030                272              SUBI.B  #$30,D3             *subracthex value of 0 to get correct value of input
00001176  D803                     273              ADD.B   D3,D4               *
00001178  4EF9 000011A0            274              JMP     resume              *return to top
0000117E                           275              
0000117E                           276  upper2hex
0000117E  0403 0037                277              SUBI.B  #$37,D3             *subracthex value of A to get correct value of input
00001182  D803                     278              ADD.B   D3,D4               *
00001184  4EF9 000011A0            279              JMP     resume              *return to top
0000118A                           280              
0000118A                           281  lower2hex
0000118A  0403 0057                282              SUBI.B  #$57,D3             *subracthex value of a to get correct value of input
0000118E  D803                     283              ADD.B   D3,D4               *
00001190  4EF9 000011A0            284              JMP     resume              *return to top
00001196                           285  error
00001196  1A3C 0000                286              MOVE.B  #$00,D5             *flag as bad input and return
0000119A  4EF9 000011B8            287              JMP     endA2H              *return to top
000011A0                           288  resume
000011A0  5246                     289              ADD     #1,D6               *increment length counter
000011A2  BC7C 0006                290              CMP     #6,D6               *check if done
000011A6  6700 0010                291              BEQ     endA2H              *
000011AA  0C11 0000                292              CMP.B   #$00,(A1)           *end of string??
000011AE  6700 0008                293              BEQ     endA2H              *
000011B2  E984                     294              ASL.L   #4,D4               *shiftleft by 4 bits to get next value            
000011B4  4EF8 1138                295              JMP     loop                *return to top
000011B8                           296  
000011B8                           297  endA2H
000011B8  2044                     298              MOVE.L  D4,A0               *
000011BA  2E04                     299              MOVE.L  D4,D7               *move address to temp register
000011BC  4246                     300              CLR     D6                  *clear counter
000011BE  4CDF 001F                301              MOVEM.L (SP)+,D0-D4         *load data registers from stack      
000011C2  4E75                     302              RTS                         *
000011C4                           303  *===========================================================
000011C4                           304  
000011C4                           305  ************************************************************
000011C4                           306  *BUFFER_PREP
000011C4                           307  ************************************************************
000011C4                           308  BUFFER_PREP:
000011C4  45F9 00009000            309              LEA     buf, A2             *load buffer
000011CA  224A                     310              MOVEA.L A2,A1               *load trap address with buffer 
000011CC  4EB9 000011E8            311              JSR     ADDRESS             *current address to buffer
000011D2                           312              *MOVE.L  #$BA3C, (A0)        *CMP test case
000011D2  2E10                     313              MOVE.L  (A0), D7
000011D4                           314  
000011D4  4EB9 00001230            315              JSR     GETOPCODE           *decode instruction
000011DA  14BC 0000                316              MOVE.B  #00,(A2)            *null terminator
000011DE  103C 000D                317              MOVE.B  #task13,D0
000011E2  4E4F                     318              TRAP    #15 
000011E4                           319  
000011E4  5448                     320              ADDQ.W      #2, A0
000011E6                           321   
000011E6  4E75                     322  endBP       RTS
000011E8                           323  *===========================================================                       
000011E8                           324  
000011E8                           325  ************************************************************
000011E8                           326  *ADDRESS
000011E8                           327  *Description: Fills the buffer with the current address
000011E8                           328  ************************************************************
000011E8                           329  ADDRESS:    
000011E8  4283                     330              CLR.L   D3
000011EA  4284                     331              CLR.L   D4
000011EC  4287                     332              CLR.L   D7
000011EE  14FC 0024                333              MOVE.B  #$24, (A2)+        
000011F2  7600                     334              MOVE.L  #$00000000, D3
000011F4  2E08                     335              MOVE.L  A0, D7
000011F6  D647                     336              ADD.W   D7, D3
000011F8  4EB9 00001208            337              JSR     addrFill   
000011FE  14FC 0009                338              MOVE.B  #$09,(A2)+   *tab
00001202  4EF9 0000122C            339              JMP     endaddr
00001208                           340              
00001208  2403                     341  addrFill    MOVE.L      D3, D2            *move current word into D2 for rolling purposes
0000120A  183C 0008                342              MOVE.B      #8, D4              *load counter
0000120E                           343  
0000120E                           344  addrLoop                 
0000120E  B83C 0000                345              CMP.B       #$00, D4            *compare counter with 0
00001212  6700 0018                346              BEQ         endaddr      *if 0, return
00001216  E99A                     347              ROL.L       #4, D2              *
00001218  2602                     348              MOVE.L      D2, D3              *
0000121A  0283 0000000F            349              ANDI.L      #$000F, D3          *isolate
00001220  4EB9 000017AE            350              JSR         HEX2ASCII           *to buffer           
00001226  5304                     351              SUBQ.B      #$1, D4             *subtract from counter
00001228  4EF8 120E                352              JMP         addrLoop                 *loop
0000122C                           353              
0000122C  2607                     354  endaddr     MOVE.L      D7, D3              *load from utility                             
0000122E  4E75                     355  endbf       RTS
00001230                           356  *===========================================================
00001230                           357  
00001230                           358  ************************************************************ 
00001230                           359  *   ___  ____   ____ ___  ____  _____ ____  
00001230                           360  *  / _ \|  _ \ / ___/ _ \|  _ \| ____/ ___| 
00001230                           361  * | | | | |_) | |  | | | | | | |  _| \___ \ 
00001230                           362  * | |_| |  __/| |__| |_| | |_| | |___ ___) |
00001230                           363  *  \___/|_|    \____\___/|____/|_____|____/ 
00001230                           364  * 
00001230                           365  *GETOPCODE:
00001230                           366  *Description: Gets the first four bits of instruction to decode 
00001230                           367  *  
00001230                           368  *Naming conventions for opcode subroutines
00001230                           369  *opcode####
00001230                           370  *op[opmode][operation]
00001230                           371  *endop####
00001230                           372  *                              
00001230                           373  *Registers Used:
00001230                           374  *For consistency, please utilize registers in the following way.
00001230                           375  *
00001230                           376  *D1 - utility register
00001230                           377  *D3 - utility register
00001230                           378  *D7 - copy of working address
00001230                           379  *
00001230                           380  *A2 - buffer address of decoded instruction
00001230                           381  *A6 - jump table               
00001230                           382  ************************************************************
00001230                           383  GETOPCODE:   
00001230  3607                     384              MOVE.W  D7, D3              *move to utility
00001232  123C 000C                385              MOVE.B  #12, D1             *
00001236  E26B                     386              LSR.W   D1, D3              *shift
00001238  C6FC 0006                387              MULU    #6, D3              *offset          
0000123C  4DF9 00001250            388              LEA     OP_TABLE, A6        *                                                                                  
00001242  4EB6 3000                389              JSR     00(A6,D3)           *jump indirect with index (00 indicates word movement)
00001246  260A                     390              MOVE.L  A2, D3
00001248  23C3 00001FF4            391              MOVE.L  D3, bufferend   
0000124E  4E75                     392  endgop      RTS                         *return
00001250                           393  *===========================================================
00001250                           394  
00001250                           395  ************************************************************
00001250                           396  *OPCODE Table
00001250                           397  *Description: Table of OPCODES
00001250                           398  ************************************************************ 
00001250                           399  OP_TABLE
00001250  4EF9 000012B0            400              JMP         opcode0000
00001256  4EF9 000012B8            401              JMP         opcode0001
0000125C  4EF9 000012F0            402              JMP         opcode0010
00001262  4EF9 00001330            403              JMP         opcode0011
00001268  4EF9 00001370            404              JMP         opcode0100
0000126E  4EF9 00001378            405              JMP         opcode0101
00001274  4EF9 00001380            406              JMP         opcode0110
0000127A  4EF9 00001388            407              JMP         opcode0111
00001280  4EF9 00001390            408              JMP         opcode1000
00001286  4EF9 00001398            409              JMP         opcode1001
0000128C  4EF9 00001442            410              JMP         opcode1010
00001292  4EF9 0000144A            411              JMP         opcode1011
00001298  4EF9 000014E6            412              JMP         opcode1100
0000129E  4EF9 00001572            413              JMP         opcode1101
000012A4  4EF9 00001628            414              JMP         opcode1110
000012AA  4EF9 00001630            415              JMP         opcode1111
000012B0                           416              
000012B0                           417  ************************************************************
000012B0                           418  *OPCODES
000012B0                           419  *Description: OPCODE subroutines used to decode instructions
000012B0                           420  ************************************************************          
000012B0                           421  
000012B0                           422  *SUB
000012B0                           423  *Cases for first four bits: 1001
000012B0                           424  *Description: Converts opcode instruction that start with 1001
000012B0                           425  *SUB, SUBA
000012B0                           426  * 1001 0110 0100 0001
000012B0                           427  * ^--^
000012B0                           428  *Registers Used:
000012B0                           429  *D3 - size bit
000012B0                           430  *D7 - copy of instruction
000012B0                           431  *A2 - buffer address of decoded instruction
000012B0                           432  *
000012B0                           433  ************************************************************  
000012B0                           434  * Case for: 0000
000012B0                           435  * --(ORI,ANDI,SUBI,ADDI,EORI,CMPI) 
000012B0  4EF9 000018CC            436  opcode0000: JMP     BADINST
000012B6  4E75                     437  endop0000   RTS
000012B8                           438  *===========================================================
000012B8                           439  
000012B8                           440  ************************************************************  
000012B8                           441  * Case for: 0001
000012B8                           442  * --(MOVE.B)
000012B8                           443  opcode0001:
000012B8  14FC 004D                444              MOVE.B  #$4D, (A2)+     *'M' to buffer
000012BC  14FC 004F                445              MOVE.B  #$4F, (A2)+     *'O' to buffer
000012C0  14FC 0056                446              MOVE.B  #$56, (A2)+     *'V' to buffer
000012C4  14FC 0045                447              MOVE.B  #$45, (A2)+     *'E' to buffer
000012C8  14FC 002E                448              MOVE.B  #$2E, (A2)+     *'.' to buffer
000012CC  14FC 0042                449              MOVE.B  #$42, (A2)+     *'B' to buffer
000012D0  14FC 0020                450              MOVE.B  #$20, (A2)+     *' ' to buffer
000012D4  14FC 0020                451              MOVE.B  #$20, (A2)+     *' ' to buffer
000012D8  4EB9 00001638            452              JSR     GETEA
000012DE  14FC 002C                453              MOVE.B  #$2C, (A2)+     *',' to buffer
000012E2  4EB9 00001758            454              JSR     SWAPREG         *swap destination and source regs
000012E8  4EB9 00001638            455              JSR     GETEA  
000012EE  4E75                     456  endop0001   RTS                     *return
000012F0                           457  
000012F0                           458  *===========================================================
000012F0                           459  
000012F0                           460  ************************************************************  
000012F0                           461  * Case for: 0010
000012F0                           462  * --(MOVE.L, MOVEA.L)
000012F0                           463  opcode0010: 
000012F0  24FC 4D4F5645            464                 MOVE.L   #$4D4F5645, (A2)+ ** Loads "MOVE" INTO PRINT_BUFFER
000012F6                           465  
000012F6  3607                     466                 MOVE.W   D7, D3    *Check the destination mode to see if addressing*
000012F8  C6BC 000001C0            467                 AND.L    #$01C0, D3 
000012FE  0C83 00000040            468                 CMPI.L   #$0040, D3 ** compares to see if addressing mode
00001304  660C                     469                 BNE.S    code0010_cont **branches if destination mode is not addressing register
00001306  34FC 412E                470                 MOVE.W   #$412E, (A2)+ **Loads "A." into the print_buffer
0000130A  34FC 4C20                471                 MOVE.W   #$4C20, (A2)+ **Loads "L   " into the print_buffer
0000130E  6000 0008                472                 BRA      code0010_cont2 **branches back to code
00001312                           473                 
00001312                           474                 
00001312  24FC 2E4C2020            475  code0010_cont  MOVE.L #$2E4C2020, (A2)+ **Loads ".L" into the print_buffer 
00001318                           476                 
00001318                           477  code0010_cont2      
00001318  4EB9 00001638            478                 JSR     GETEA
0000131E  14FC 002C                479                 MOVE.B  #$2C, (A2)+     *',' to buffer
00001322  4EB9 00001758            480                 JSR     SWAPREG         *swap destination and source regs
00001328  4EB9 00001638            481                 JSR     GETEA 
0000132E                           482  
0000132E  4E75                     483  endop0010   RTS
00001330                           484  *===========================================================
00001330                           485  
00001330                           486  ************************************************************  
00001330                           487  * Case for: 0011
00001330                           488  * --(MOVE.W, MOVEA.W)
00001330                           489  opcode0011:
00001330  24FC 4D4F5645            490                 MOVE.L   #$4D4F5645, (A2)+ ** Loads "MOVE" INTO PRINT_BUFFER
00001336                           491  
00001336  3607                     492                 MOVE.W   D7, D3    *Check the destination mode to see if addressing*
00001338  C6BC 000001C0            493                 AND.L    #$01C0, D3 
0000133E  0C83 00000040            494                 CMPI.L   #$0040, D3 ** compares to see if addressing mode
00001344  660C                     495                 BNE.S    code0011_cont **branches if destination mode is not addressing register
00001346  34FC 412E                496                 MOVE.W   #$412E, (A2)+ **Loads "A." into the print_buffer
0000134A  34FC 5720                497                 MOVE.W   #$5720, (A2)+ **Loads "W   " into the print_buffer
0000134E  6000 0008                498                 BRA      code0011_cont2 **branches back to code
00001352                           499                 
00001352  24FC 2E572020            500  code0011_cont  MOVE.L   #$2E572020, (A2)+ **Loads ".W" into the print_buffer 
00001358                           501                 
00001358                           502                 
00001358                           503  code0011_cont2 
00001358  4EB9 00001638            504                 JSR      GETEA
0000135E  14FC 002C                505                 MOVE.B   #$2C, (A2)+     *',' to buffer
00001362  4EB9 00001758            506                 JSR      SWAPREG         *swap destination and source regs
00001368  4EB9 00001638            507                 JSR      GETEA 
0000136E  4E75                     508                 RTS
00001370                           509  
00001370                           510  *===========================================================
00001370                           511  
00001370                           512  ************************************************************  
00001370                           513  * Case for: 0100
00001370                           514  * --(CLR,MOVEM,JMP,JSR,RTS,LEA) 
00001370  4EF9 000018CC            515  opcode0100: JMP          BADINST
00001376  4E75                     516  endop0100   RTS
00001378                           517  ************************************************************  
00001378                           518  * Case for: 0101
00001378                           519  * --BAD INSTRUCTION
00001378  4EF9 000018CC            520  opcode0101: JMP     BADINST
0000137E  4E75                     521  endop0101   RTS
00001380                           522  *===========================================================
00001380                           523  
00001380                           524  ************************************************************  
00001380                           525  * Case for: 0110
00001380                           526  * --(Bcc)
00001380  4EF9 000018CC            527  opcode0110: JMP     BADINST
00001386  4E75                     528  endop0110   RTS
00001388                           529  *===========================================================
00001388                           530  
00001388                           531  ************************************************************  
00001388                           532  * Case for: 0111
00001388                           533  * --BAD INSTRUCTION
00001388  4EF9 000018CC            534  opcode0111: JMP     BADINST
0000138E  4E75                     535  endop0111   RTS
00001390                           536  *===========================================================
00001390                           537  
00001390                           538  ************************************************************  
00001390                           539  * Case for: 1000
00001390                           540  * --(OR) 
00001390  4EF9 000018CC            541  opcode1000: JMP     BADINST
00001396  4E75                     542  endop1000   RTS
00001398                           543  *===========================================================
00001398                           544  
00001398                           545  ************************************************************  
00001398                           546  * Case for: 1001
00001398                           547  * --(SUB, SUBA)
00001398                           548  opcode1001:
00001398  14FC 0053                549              MOVE.B  #$53, (A2)+     *'S' to buffer
0000139C  14FC 0055                550              MOVE.B  #$55, (A2)+     *'U' to buffer
000013A0  14FC 0042                551              MOVE.B  #$42, (A2)+     *'B' to buffer
000013A4  4EB9 00001744            552              JSR     GETSIZE         *get the instruction size (OPMODE)
000013AA  B63C 0003                553              CMP.B   #%11, D3        *11 = SUBA  
000013AE  6600 0046                554              BNE     opsubSub
000013B2  14FC 0041                555              MOVE.B  #$41, (A2)+     *'A' to buffer
000013B6  14FC 002E                556              MOVE.B  #$2E, (A2)+     *'.' to buffer
000013BA  3607                     557              MOVE.W  D7, D3          *move to utility
000013BC  E08B                     558              LSR.L   #8, D3          *shift for opmode
000013BE  0243 0001                559              ANDI.W  #$0001, D3      *isolate 8 to determine size
000013C2  B63C 0001                560              CMP.B   #%1, D3         *long?
000013C6  6700 0008                561              BEQ     opsubL          *it's a longword
000013CA  4EF9 000013D4            562              JMP     opsubSuba
000013D0                           563  **SUBA******************************************************            
000013D0  14FC 004C                564  opsubL      MOVE.B  #$4C, (A2)+     *'L' to buffer
000013D4  14FC 0020                565  opsubSuba   MOVE.B  #$20, (A2)+     *' ' to buffer    
000013D8  14FC 0020                566              MOVE.B  #$20, (A2)+     *' ' to buffer
000013DC  4EB9 00001638            567              JSR     GETEA           *get effective address
000013E2  14FC 002C                568              MOVE.B  #$2C,(A2)+      *'B' to buffer
000013E6  14FC 0041                569              MOVE.B  #$41,(A2)+      *'B' to buffer
000013EA  4EB9 000017C6            570              JSR     REG2BUFFER      *get the register number
000013F0  4EF9 00001440            571              JMP     endop1001       *return
000013F6                           572  **SUB*EA>>Register****************************************** 
000013F6  14FC 002E                573  opsubSub    MOVE.B  #$2E, (A2)+     *'B' to buffer
000013FA  4EB9 000017D8            574              JSR     SIZE2BUFFER     *send size to buffer
00001400  14FC 0009                575              MOVE.B  #$09, (A2)+     *tab
00001404  4EB9 0000174E            576              JSR     GETDIRECTION    *isolate bit for direction
0000140A  B63C 0000                577              CMP.B   #%0, D3         *direction bit 0 = EA; 1 = regs
0000140E  6600 001C                578              BNE     opsubSubR         
00001412  4EB9 00001638            579              JSR     GETEA           *get effective address
00001418  14FC 002C                580              MOVE.B  #$2C,(A2)+      *',' to buffer   
0000141C  14FC 0044                581              MOVE.B  #$44,(A2)+      *'D' to buffer
00001420  4EB9 000017C6            582              JSR     REG2BUFFER      *get the register number
00001426  4EF9 00001440            583              JMP     endop1001       *return
0000142C                           584  **SUB*Register>>EA******************************************            
0000142C  14FC 0044                585  opsubSubR   MOVE.B  #$44,(A2)+      *'D' to buffer
00001430  4EB9 000017C6            586              JSR     REG2BUFFER      *get the register number
00001436  14FC 002C                587              MOVE.B  #$2C,(A2)+      *',' to buffer
0000143A  4EB9 00001638            588              JSR     GETEA           *get effective address
00001440  4E75                     589  endop1001   RTS                     *return
00001442                           590  *===========================================================
00001442                           591                                                         
00001442                           592  ************************************************************  
00001442                           593  * Case for: 1010
00001442                           594  * --BAD INSTRUCTION
00001442  4EF9 000018CC            595  opcode1010: JMP     BADINST
00001448  4E75                     596  endop1010   RTS
0000144A                           597  *===========================================================
0000144A                           598  
0000144A                           599  ************************************************************  
0000144A                           600  * Case for: 1011
0000144A                           601  * --(CMP,CMPA)
0000144A                           602  *EOR is not applicable to this assignment and will be 
0000144A                           603  *regarded as a bad instruction
0000144A                           604  opcode1011: 
0000144A  4EB9 00001744            605              JSR     GETSIZE
00001450  B63C 0003                606              CMP.B   #%11, D3
00001454  6600 0040                607              BNE     opcmp
00001458                           608              
00001458  14FC 0043                609  opCMPA      MOVE.B  #$43, (A2)+     *'C' to buffer
0000145C  14FC 004D                610              MOVE.B  #$4D, (A2)+     *'M' to buffer
00001460  14FC 0050                611              MOVE.B  #$50, (A2)+     *'P' to buffer
00001464  14FC 0041                612              MOVE.B  #$41, (A2)+     *'A' to buffer
00001468  14FC 002E                613              MOVE.B  #$2E, (A2)+     *'.' to buffer
0000146C  2607                     614              MOVE.L  D7, D3
0000146E  14FC 0020                615              MOVE.B  #$20, (A2)+     *' ' to buffer
00001472  14FC 0020                616              MOVE.B  #$20, (A2)+     *' ' to buffer
00001476                           617              
00001476  4EB9 000017D8            618              JSR     SIZE2BUFFER
0000147C  4EB9 00001638            619              JSR     GETEA
00001482  14FC 002C                620              MOVE.B  #$2C, (A2)+     *',' to buffer
00001486  14FC 0041                621              MOVE.B  #$41, (A2)+     *'A' to buffer
0000148A  4EB9 000017C6            622              JSR     REG2BUFFER
00001490  4EF9 000014E4            623              JMP     endop1011
00001496                           624              
00001496  2607                     625  opCMP       MOVE.L  D7, D3
00001498  4EB9 0000174E            626              JSR     GETDIRECTION
0000149E  B63C 0000                627              CMP.B   #%0, D3
000014A2  6600 003A                628              BNE     opeor
000014A6                           629  
000014A6  14FC 0043                630              MOVE.B  #$43, (A2)+     *'C' to buffer
000014AA  14FC 004D                631              MOVE.B  #$4D, (A2)+     *'M' to buffer
000014AE  14FC 0050                632              MOVE.B  #$50, (A2)+     *'P' to buffer
000014B2  14FC 002E                633              MOVE.B  #$2E, (A2)+     *'.' to buffer
000014B6  4EB9 000017D8            634              JSR     SIZE2BUFFER
000014BC  14FC 0020                635              MOVE.B  #$20, (A2)+     *' ' to buffer
000014C0  14FC 0020                636              MOVE.B  #$20, (A2)+     *' ' to buffer
000014C4  4EB9 00001638            637              JSR     GETEA
000014CA  14FC 002C                638              MOVE.B  #$2C, (A2)+     *',' to buffer
000014CE  14FC 0044                639              MOVE.B  #$44, (A2)+     *'D' to buffer
000014D2  4EB9 000017C6            640              JSR     REG2BUFFER
000014D8  4EF9 000014E4            641              JMP     endop1011
000014DE                           642              
000014DE  4EF9 000018CC            643  opEOR       JMP     BADINST            
000014E4                           644              
000014E4  4E75                     645  endop1011   RTS
000014E6                           646  *===========================================================
000014E6                           647  
000014E6                           648  ************************************************************  
000014E6                           649  * Case for: 1100
000014E6                           650  * --(AND)
000014E6                           651  *MULU, EXG are not applicable to this assignment and will be 
000014E6                           652  *regarded as a bad instruction
000014E6                           653  opcode1100:
000014E6  3607                     654              MOVE.W  D7, D3          *move to utility
000014E8  EC8B                     655              LSR.L   #6, D3          *shift
000014EA  0243 0003                656              ANDI.W  #$3, D3         *isolate
000014EE  B63C 0003                657              CMP.B   #$3, D3         *MULU/MULS?
000014F2  6700 03D8                658              BEQ     BADINST         *instruction not supported
000014F6                           659              
000014F6  3607                     660              MOVE.W  D7, D3          *move to utility
000014F8  E68B                     661              LSR.L   #3, D3          *shift
000014FA  0203 001F                662              ANDI.B  #$1F, D3        *isolate
000014FE  B63C 0008                663              CMP.B   #$08, D3        *EXG?
00001502  6700 03C8                664              BEQ     BADINST         *instruction not supported
00001506  B63C 0009                665              CMP.B   #$09, D3        *EXG?
0000150A  6700 03C0                666              BEQ     BADINST         *instruction not supported
0000150E  B63C 0011                667              CMP.B   #$11, D3        *EXG?
00001512  6700 03B8                668              BEQ     BADINST         *ok, phew made it to AND
00001516                           669              
00001516  14FC 0041                670              MOVE.B  #$41, (A2)+     *'A' to buffer
0000151A  14FC 004E                671              MOVE.B  #$4E, (A2)+     *'N' to buffer
0000151E  14FC 0044                672              MOVE.B  #$44, (A2)+     *'D' to buffer
00001522  14FC 002E                673              MOVE.B  #$2E, (A2)+     *'.' to buffer
00001526  4EB9 000017D8            674              JSR     SIZE2BUFFER     *send size to buffer
0000152C  14FC 0020                675              MOVE.B  #$20, (A2)+     *' ' to buffer
00001530  14FC 0020                676              MOVE.B  #$20, (A2)+     *' ' to buffer
00001534  4EB9 0000174E            677              JSR     GETDIRECTION    *isolate bit for direction
0000153A  0C03 0000                678              CMPI.B  #%0, D3         *direction bit 0 = EA; 1 = regs
0000153E  6600 001C                679              BNE     opandd01        *direction = 01
00001542  4EB9 00001638            680              JSR     GETEA           *get effective address
00001548  14FC 002C                681              MOVE.B  #$2C, (A2)+     *',' to buffer
0000154C  14FC 0044                682              MOVE.B  #$44, (A2)+     *'D' to buffer
00001550  4EB9 000017C6            683              JSR     REG2BUFFER      *get the register number
00001556  4EF9 00001570            684              JMP     endop1100     
0000155C                           685           
0000155C  14FC 0044                686  opandd01    MOVE.B  #$44, (A2)+     *'D' to buffer
00001560  4EB9 000017C6            687              JSR     REG2BUFFER      *get the register number
00001566  14FC 002C                688              MOVE.B  #$2C, (A2)+     *',' to buffer
0000156A  4EB9 00001638            689              JSR     GETEA           *get effective address 
00001570  4E75                     690  endop1100   RTS                     *return
00001572                           691  *===========================================================
00001572                           692  
00001572                           693  ************************************************************  
00001572                           694  * Case for: 1101
00001572                           695  * --(ADD,ADDA)
00001572                           696  opcode1101: 
00001572  14FC 0041                697              MOVE.B  #$41, (A2)+     *'A' to buffer
00001576  14FC 0044                698              MOVE.B  #$44, (A2)+     *'D' to buffer
0000157A  14FC 0044                699              MOVE.B  #$44, (A2)+     *'D' to buffer
0000157E  4EB9 00001744            700              JSR     GETSIZE         *
00001584  0C03 0003                701              CMPI.B  #%11, D3        *11?
00001588  6600 004E                702              BNE     opadd           *
0000158C  14FC 0041                703              MOVE.B  #$41, (A2)+     *'A' to buffer
00001590  14FC 002E                704              MOVE.B  #$2E, (A2)+     *'.' to buffer
00001594  3607                     705              MOVE.W  D7, D3          *move to utility
00001596  E08B                     706              LSR.L   #8, D3          *shift
00001598  0243 0001                707              ANDI.W  #$0001, D3      *isolate
0000159C  0C03 0001                708              CMPI.B  #%1, D3         *long?
000015A0  6700 000C                709              BEQ     opaddL          *
000015A4  14FC 0057                710              MOVE.B  #$57,(A2)+      *'W' to buffer
000015A8  4EF9 000015B2            711              JMP     opadda  
000015AE                           712  *ADD.L******************************************************
000015AE  14FC 004C                713  opaddL      MOVE.B  #$4C,(A2)+      *'L' to buffer
000015B2                           714  *ADDA*******************************************************
000015B2  14FC 0020                715  opadda      MOVE.B  #$20, (A2)+     *' ' to buffer
000015B6  14FC 0020                716              MOVE.B  #$20, (A2)+     *' ' to buffer
000015BA  14FC 0020                717              MOVE.B  #$20, (A2)+     *' ' to buffer
000015BE  4EB9 00001638            718              JSR     GETEA           *get effective address 
000015C4  14FC 002C                719              MOVE.B  #$2C, (A2)+     *',' to buffer
000015C8  14FC 0041                720              MOVE.B  #$41, (A2)+     *'A' to buffer
000015CC  4EB9 000017C6            721              JSR     REG2BUFFER      *get the register number
000015D2  4EF9 00001626            722              JMP     endop1101
000015D8                           723  *ADD********************************************************
000015D8  14FC 002E                724  opadd       MOVE.B  #$2E, (A2)+     *'.' to buffer  
000015DC  4EB9 000017D8            725              JSR     SIZE2BUFFER     *send size to buffer
000015E2  14FC 0020                726              MOVE.B  #$20, (A2)+     *' ' to buffer
000015E6  14FC 0020                727              MOVE.B  #$20, (A2)+     *' ' to buffer
000015EA  4EB9 0000174E            728              JSR     GETDIRECTION    *isolate bit for direction
000015F0  0C03 0000                729              CMPI.B   #%0, D3         *direction bit 0 = EA; 1 = regs
000015F4  6600 001C                730              BNE     opaddd01        *
000015F8  4EB9 00001638            731              JSR     GETEA           *get effective address
000015FE  14FC 002C                732              MOVE.B  #$2C, (A2)+     *',' to buffer
00001602  14FC 0044                733              MOVE.B  #$44, (A2)+     *'D' to buffer
00001606  4EB9 000017C6            734              JSR     REG2BUFFER      *get the register number
0000160C  4EF9 00001626            735              JMP     endop1101   
00001612                           736  *EA first*************************************************** 
00001612  14FC 0044                737  opaddd01    MOVE.B  #$44, (A2)+     *'D' to buffer
00001616  4EB9 000017C6            738              JSR     REG2BUFFER      *get the register number
0000161C  14FC 002C                739              MOVE.B  #$2C, (A2)+     *',' to buffer
00001620  4EB9 00001638            740              JSR     GETEA           *get effective address
00001626  4E75                     741  endop1101   RTS                     *return           
00001628                           742  *===========================================================
00001628                           743  
00001628                           744  ************************************************************  
00001628                           745  * Case for: 1110
00001628                           746  * --(ASR, LSL)
00001628  4EF9 000018CC            747  opcode1110: JMP     BADINST
0000162E  4E75                     748  endop1110   RTS
00001630                           749  *===========================================================
00001630                           750  
00001630                           751  ************************************************************  
00001630                           752  * Case for: 1111
00001630                           753  * --BAD INSTRUCTION
00001630  4EF9 000018CC            754  opcode1111: JMP     BADINST
00001636  4E75                     755  endop111    RTS
00001638                           756   *===========================================================             
00001638                           757  
00001638                           758  ************************************************************
00001638                           759  *  _____ _____ _____ _____ ____ _____ _____     _______      _    ____  ____  ____  _____ ____ ____  
00001638                           760  * | ____|  ___|  ___| ____/ ___|_   _|_ _\ \   / / ____|    / \  |  _ \|  _ \|  _ \| ____/ ___/ ___| 
00001638                           761  * |  _| | |_  | |_  |  _|| |     | |  | | \ \ / /|  _|     / _ \ | | | | | | | |_) |  _| \___ \___ \ 
00001638                           762  * | |___|  _| |  _| | |__| |___  | |  | |  \ V / | |___   / ___ \| |_| | |_| |  _ <| |___ ___) |__) |
00001638                           763  * |_____|_|   |_|   |_____\____| |_| |___|  \_/  |_____| /_/   \_\____/|____/|_| \_\_____|____/____/ 
00001638                           764  *                                                                                                   
00001638                           765  *GETEA
00001638                           766  *Description: Converts the opcode instruction EA
00001638                           767  * 1001 0110 0100 0001
00001638                           768  *             ^-----^
00001638                           769  *Registers Used:
00001638                           770  *For consistency, please utilize registers in the following way.
00001638                           771  *
00001638                           772  *D1 - utility register
00001638                           773  *D3 - utility register
00001638                           774  *D7 - copy of working address
00001638                           775  *
00001638                           776  *A2 - buffer address of decoded instruction
00001638                           777  *A6 - jump table
00001638                           778  ************************************************************
00001638                           779  GETEA:
00001638                           780              *MOVE.W  #$4541, (A2)+   *'EA' to buffer
00001638                           781              *TODO
00001638  4DF9 00001656            782              LEA     EA_TABLE, A6
0000163E  4283                     783              CLR.L   D3
00001640  3607                     784              MOVE.W  D7, D3
00001642  0243 003F                785              ANDI.W  #$003F, D3
00001646  123C 0003                786              MOVE.B  #3, D1
0000164A  E26B                     787              LSR.W   D1, D3
0000164C  C6FC 0006                788              MULU    #6, D3
00001650  4EB6 3000                789              JSR     0(A6, D3)
00001654  4E75                     790              RTS                     *return
00001656                           791  *===========================================================
00001656                           792  
00001656                           793  ************************************************************
00001656                           794  *GET_TABLE
00001656                           795  *Description: Jump table of Effective Address Modes
00001656                           796  ************************************************************
00001656                           797  EA_TABLE:       
00001656  4EF9 00001686            798              JMP     eacode000
0000165C  4EF9 00001698            799              JMP     eacode001
00001662  4EF9 000016AA            800              JMP     eacode010
00001668  4EF9 000016C4            801              JMP     eacode011
0000166E  4EF9 000016E2            802              JMP     eacode100
00001674  4EF9 00001700            803              JMP     eacode101
0000167A  4EF9 00001708            804              JMP     eacode110
00001680  4EF9 00001710            805              JMP     eacode111
00001686                           806  *===========================================================
00001686                           807  
00001686                           808  ************************************************************
00001686                           809  *EA CODES
00001686                           810  *Description: Lsit of Effective Address Subrotines
00001686                           811  *000,001,010,011,100,[101],[110],111
00001686                           812  *Registers Used:
00001686                           813  *TODO
00001686                           814  *
00001686                           815  *Data Register**********************************************
00001686  3607                     816  eacode000   MOVE.W      D7, D3          *move to utility
00001688  0243 0007                817              ANDI.W      #$7, D3         *isolate
0000168C  14FC 0044                818              MOVE.B      #$44,(A2)+      *'D' to buffer
00001690  0603 0030                819              ADD.B       #$30, D3        *convert register number to ascii
00001694  14C3                     820              MOVE.B      D3,(A2)+        *to buffer                  
00001696  4E75                     821  endea000    RTS                         *return
00001698                           822  
00001698                           823  *Address Register*******************************************
00001698  3607                     824  eacode001   MOVE.W      D7, D3          *move to utility
0000169A  0243 0007                825              ANDI.W      #$7, D3         *isolate
0000169E  14FC 0041                826              MOVE.B      #$41, (A2)+     *'A' to buffer
000016A2  0603 0030                827              ADD.B       #$30, D3        *convert register number to ascii
000016A6  14C3                     828              MOVE.B      D3,(A2)+        *to buffer  
000016A8  4E75                     829  endea001    RTS                         *return
000016AA                           830  
000016AA                           831  *Address
000016AA  3607                     832  eacode010   MOVE.W      D7, D3          *move to utility
000016AC  0243 0007                833              ANDI.W      #$7, D3         *isolate
000016B0  14FC 0028                834              MOVE.B      #$28,(A2)+      *'(' to buffer            
000016B4  14FC 0041                835              MOVE.B      #$41,(A2)+      *'A' to buffer
000016B8  0603 0030                836              ADD.B       #$30, D3        *convert register number to ascii
000016BC  14C3                     837              MOVE.B      D3,(A2)+        *to buffer  
000016BE  14FC 0029                838              MOVE.B      #$29,(A2)+      *')' to buffe
000016C2  4E75                     839  endea010    RTS                         *return
000016C4                           840  
000016C4                           841  *Address with Postincrement*********************************
000016C4  3607                     842  eacode011   MOVE.W      D7, D3          *move to utility
000016C6  0243 0007                843              ANDI.W      #$7, D3         *isolate
000016CA  14FC 0028                844              MOVE.B      #$28,(A2)+      *'(' to buffer            
000016CE  14FC 0041                845              MOVE.B      #$41,(A2)+      *'A' to buffer
000016D2  0603 0030                846              ADD.B       #$30, D3        *convert register number to ascii
000016D6  14C3                     847              MOVE.B      D3,(A2)+        *to buffer  
000016D8  14FC 0029                848              MOVE.B      #$29,(A2)+      *')' to buffer
000016DC  14FC 002B                849              MOVE.B      #$2B, (A2)+     *'+' to buffer
000016E0  4E75                     850  endea011    RTS                         *return
000016E2                           851  
000016E2                           852  *Address with Predecrement**********************************
000016E2  3607                     853  eacode100   MOVE.W      D7, D3          *move to utility
000016E4  0243 0007                854              ANDI.W      #$7, D3         *isolate
000016E8  14FC 002D                855              MOVE.B      #$2D,(A2)+      *'-' to buffer 
000016EC  14FC 0028                856              MOVE.B      #$28,(A2)+      *'(' to buffer            
000016F0  14FC 0041                857              MOVE.B      #$41,(A2)+      *'A' to buffer
000016F4  0603 0030                858              ADD.B       #$30, D3        *convert register number to ascii
000016F8  14C3                     859              MOVE.B      D3,(A2)+        *to buffer  
000016FA  14FC 0029                860              MOVE.B      #$29,(A2)+      *')' to buffe
000016FE  4E75                     861  endea100    RTS                         *return
00001700                           862  
00001700                           863  *Bad Instruction********************************************
00001700  4EF9 000018CC            864  eacode101   JMP         BADINST
00001706  4E75                     865  endea101    RTS 
00001708                           866  *Bad Instruction********************************************
00001708  4EF9 000018CC            867  eacode110   JMP         BADINST
0000170E  4E75                     868  endea110    RTS 
00001710                           869  *Immediate**************************************************
00001710  4EB9 0000173C            870  eacode111   JSR         GETREGISTER     *isolate register bits
00001716  0C03 0004                871              CMPI.B      #$4, D3         *Immediate Data?
0000171A  6700 0192                872              BEQ         IMM2BUFER
0000171E  0C03 0002                873              CMPI.B      #$2, D3         *PC?
00001722  6700 01A8                874              BEQ         BADINST
00001726  14FC 0024                875              MOVE.B      #$24, (A2)+
0000172A  0C03 0000                876              CMPI.B      #$0, D3         *word?
0000172E  6700 011E                877              BEQ         WORD2BUFFER
00001732  0C03 0001                878              CMPI.B      #$1, D3         *long?
00001736  6700 0142                879              BEQ         LONG2BUFFER
0000173A                           880              
0000173A  4E75                     881  endea111    RTS                         *return
0000173C                           882  *===========================================================
0000173C                           883  
0000173C                           884  ************************************************************
0000173C                           885  *GETREGISTER
0000173C                           886  *Description: Converts register bit and stores in D3
0000173C                           887  ************************************************************ 
0000173C                           888  GETREGISTER:
0000173C  3607                     889              MOVE.W  D7, D3
0000173E  0243 0007                890              ANDI.W  #$07, D3
00001742  4E75                     891  endrb       RTS
00001744                           892  *===========================================================
00001744                           893  
00001744                           894  ************************************************************
00001744                           895  *GETSIZE
00001744                           896  *Description: Returns the size of the bit in 6-7 (.B, .W, .L)
00001744                           897  * 1001 0110 0100 0001
00001744                           898  *       ^^--------->|
00001744                           899  *Registers Used:
00001744                           900  *D3 - size bit
00001744                           901  *D7 - copy of instruction
00001744                           902  ************************************************************
00001744                           903  GETSIZE:
00001744  3607                     904              MOVE.W  D7, D3          *move to utility
00001746  EC4B                     905              LSR.W   #6, D3          *shift
00001748  0243 0003                906              ANDI.W  #$0003, D3      *isolate
0000174C  4E75                     907  endGS       RTS                     *return
0000174E                           908  *===========================================================
0000174E                           909  
0000174E                           910  
0000174E                           911  ************************************************************
0000174E                           912  *GETDIRECTION
0000174E                           913  *Description: Finds direction of the instruction and sets it to the utility register
0000174E                           914  * 1001 0110 0100 0001
0000174E                           915  *         ^-------->|
0000174E                           916  *Registers Used:
0000174E                           917  *D3 - size bit
0000174E                           918  *D7 - copy of instruction 
0000174E                           919  ************************************************************
0000174E                           920  GETDIRECTION:
0000174E  3607                     921              MOVE.W  D7, D3          *move to utility
00001750  E08B                     922              LSR.L   #8, D3          *shift 8
00001752  0203 0001                923              ANDI.B  #01, D3         *isolate 8th bit
00001756  4E75                     924  endgd       RTS                     *return
00001758                           925  *===========================================================
00001758                           926  
00001758                           927  ************************************************************
00001758                           928  *SWAPREG         
00001758                           929  *Description: For double EA move instructions, swaps registers to use EA jump table
00001758                           930  *Registers Used:
00001758                           931  *D3 - size bit
00001758                           932  *D4 - hold register for swap bits
00001758                           933  *D7 - swapped EA mode 
00001758                           934  SWAPREG:
00001758  4283                     935              CLR.L   D3              *
0000175A  3607                     936              MOVE.W  D7,D3           *move to utility
0000175C  E04B                     937              LSR.W   #8,D3           *shift
0000175E  E24B                     938              LSR.W   #1,D3           *shift
00001760  0243 0007                939              ANDI.W  #$0007,D3       *
00001764  8843                     940              OR.W    D3,D4           *store bits for swap
00001766  3607                     941              MOVE.W  D7,D3           *move to utility
00001768  C6BC 000001C0            942              AND.L   #$01C0, D3      *filter out mode*
0000176E  E64B                     943              LSR.W   #3,D3           *shift bits 6-8 to normal ea position
00001770  8843                     944              OR.W    D3,D4           *
00001772  4EB9 0000177C            945              JSR     srSize        *get mode size
00001778  3E04                     946              MOVE.W  D4,D7           *load swap register
0000177A  4E75                     947  endswap     RTS                     *return
0000177C                           948  
0000177C  3607                     949  srSize      MOVE.W  D7,D3           *move to utility
0000177E  E04B                     950              LSR.W   #8,D3           *shift
00001780  E84B                     951              LSR.W   #4,D3           *
00001782  0243 0003                952              ANDI.W  #$0003,D3       *isolate
00001786  B63C 0001                953              CMP.B   #$1,D3          *byte?
0000178A  6700 0020                954              BEQ     endsr           *yes
0000178E  B63C 0002                955              CMP.B   #$2,D3          *long?
00001792  6700 0014                956              BEQ     srL             *yes
00001796  B63C 0003                957              CMP.B   #$3,D3          *word?
0000179A  6600 0130                958              BNE     BADINST         *No? bad instrustion        
0000179E  0044 00C0                959  srW         ORI.W   #$00C0,D4       *add size
000017A2  4EF9 000017AC            960              JMP     endsr           *
000017A8  0044 0080                961  srL         ORI.W   #$0080,D4       *add size
000017AC  4E75                     962  endsr       RTS                     *return
000017AE                           963  *===========================================================
000017AE                           964  
000017AE                           965  ************************************************************
000017AE                           966  *  ____  _   _ _____ _____ _____ ____     ____ ___  _   ___     _______ ____ _____ 
000017AE                           967  * | __ )| | | |  ___|  ___| ____|  _ \   / ___/ _ \| \ | \ \   / / ____|  _ \_   _|
000017AE                           968  * |  _ \| | | | |_  | |_  |  _| | |_) | | |  | | | |  \| |\ \ / /|  _| | |_) || |  
000017AE                           969  * | |_) | |_| |  _| |  _| | |___|  _ <  | |__| |_| | |\  | \ V / | |___|  _ < | |  
000017AE                           970  * |____/ \___/|_|   |_|   |_____|_| \_\  \____\___/|_| \_|  \_/  |_____|_| \_\|_|  
000017AE                           971  *
000017AE                           972  *BUFFER SUBROUTINES                                                                                 
000017AE                           973  *Description: Puts word to print buffer
000017AE                           974  *D3 - Utility register
000017AE                           975  *D6 - Counter
000017AE                           976  *A0 - Utility address
000017AE                           977  *A2 - Address buffer
000017AE                           978  *----------------------------------------------------------- 
000017AE                           979  
000017AE                           980  ************************************************************
000017AE                           981  *HEX2ASCII
000017AE                           982  *Description: Converts bit to ASCII and send to buffer
000017AE                           983  ************************************************************            
000017AE                           984  HEX2ASCII:  
000017AE  B63C 000A                985              CMP.B       #$A, D3             * Confirm hex character?
000017B2  6C00 000A                986              BGE         letter              * Is it a letter or number?
000017B6  0603 0030                987  number      ADDI.B      #$30,D3             * Convert decimal to ASCII
000017BA  6000 0006                988              BRA         W2B                 * save to good buffer
000017BE  0603 0037                989  letter      ADDI.B      #$37,D3
000017C2  14C3                     990  W2B         MOVE.B      D3,(A2)+
000017C4  4E75                     991  endH2A      RTS
000017C6                           992  *===========================================================   
000017C6                           993  
000017C6                           994  ************************************************************
000017C6                           995  *REG2BUFFER
000017C6                           996  *Description: Finds the register size and sends it to the output buffer
000017C6                           997  * 1001 0110 0100 0001
000017C6                           998  *      ^-^--------->|
000017C6                           999  *Registers Used:
000017C6                          1000  *D3 - size bit
000017C6                          1001  *D7 - copy of instruction
000017C6                          1002  *A2 - buffer address of decoded instruction          
000017C6                          1003  ************************************************************
000017C6                          1004  REG2BUFFER:
000017C6  3607                    1005              MOVE.W  D7,D3            *move to utility
000017C8  E08B                    1006              LSR.L   #8,D3            *shift
000017CA  E28B                    1007              LSR.L   #1,D3            *shift
000017CC  0203 0007               1008              ANDI.B  #$7,D3           *isolate last 7 bits for register number
000017D0  0603 0030               1009              ADD.B   #$30,D3          *convert register number to ascii
000017D4  14C3                    1010              MOVE.B  D3,(A2)+         *to buffer
000017D6  4E75                    1011  endR2B       RTS                      *return
000017D8                          1012  *===========================================================
000017D8                          1013  
000017D8                          1014  ************************************************************
000017D8                          1015  *SIZE2BUFFER
000017D8                          1016  *Description: Isolates and converts the instruction size and sends it to the output buffer
000017D8                          1017  *              Byte, word, long read word in memory for instructions that utilize immediate
000017D8                          1018  *              data.  At the end of the instruction, the working memory address is advanced.
000017D8                          1019  *Registers Used:
000017D8                          1020  *D3 - size bit
000017D8                          1021  *A2 - buffer address of decoded instruction
000017D8                          1022  ************************************************************
000017D8                          1023  SIZE2BUFFER:
000017D8  4EB8 1744               1024              JSR     GETSIZE         *get the size of bit
000017DC  B63C 0000               1025              CMP.B   #%00, D3        *byte
000017E0  6700 001E               1026              BEQ     s2bB        
000017E4  B63C 0001               1027              CMP.B   #%01, D3        *word
000017E8  6700 0020               1028              BEQ     s2bW        
000017EC  B63C 0002               1029              CMP.B   #%10, D3        *long
000017F0  6700 0022               1030              BEQ     s2bL        
000017F4  4EB9 000018CC           1031              JSR     BADINST         *bad instruction
000017FA  4EF9 00001818           1032              JMP     ends2b      
00001800                          1033              
00001800  14FC 0042               1034  s2bB        MOVE.B  #$42,(A2)+      *'B' to buffer
00001804  4EF9 00001818           1035              JMP     ends2b      
0000180A  14FC 0057               1036  s2bW        MOVE.B  #$57,(A2)+      *'W' to buffer
0000180E  4EF9 00001818           1037              JMP     ends2b    
00001814  14FC 004C               1038  s2bL        MOVE.B  #$4C,(A2)+      *'L' to buffer
00001818  4E75                    1039  ends2b      RTS                     *return
0000181A                          1040  *===========================================================
0000181A                          1041  
0000181A                          1042  ************************************************************
0000181A                          1043  *BYTE2BUFFER
0000181A                          1044  *Description: Converts byte and sends it to the output buffer
0000181A                          1045  *Buffer: $XX
0000181A                          1046  ************************************************************
0000181A                          1047  BYTE2BUFFER:
0000181A  48E7 FE00               1048              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
0000181E                          1049              *MOVE.B      #'$', (A2)+  
0000181E  4284                    1050              CLR.L       D4                  *clear counter
00001820  2E88                    1051              MOVE.L      A0, (A7)
00001822  2E17                    1052              MOVE.L      (A7), D7
00001824  2417                    1053              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
00001826  183C 0002               1054              MOVE.B      #2, D4              *load counter
0000182A                          1055  
0000182A                          1056  b2bLoop                 
0000182A  B83C 0000               1057              CMP.B       #$00, D4            *compare counter with 0
0000182E  6700 0014               1058              BEQ         endb2b              *if zero, return
00001832  E95A                    1059              ROL.W       #4, D2              *roll the bits in D2 to the left
00001834  3602                    1060              MOVE.W      D2, D3              *move rolled bits into temp storage
00001836  0243 000F               1061              ANDI.W      #$000F, D3          *and the bits to isolate ascii char   
0000183A  4EB8 17AE               1062              JSR         HEX2ASCII           *load ascii char into buffer            
0000183E  5304                    1063              SUBQ.B      #$1, D4             *subtract from counter
00001840  4EF8 182A               1064              JMP         b2bLoop             *keep looping until counter hits zero
00001844                          1065              
00001844  3607                    1066  endb2b      MOVE.W      D7, D3              *re-load current word for temp storage            
00001846  5448                    1067              ADDQ.W      #2, A0              *advancing memory pointer by word  
00001848  4CDF 007F               1068              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
0000184C  4E75                    1069              RTS                             *return
0000184E                          1070  *===========================================================
0000184E                          1071  
0000184E                          1072  ************************************************************
0000184E                          1073  *WORD2BUFFER
0000184E                          1074  *Buffer: $XXXX
0000184E                          1075  ************************************************************
0000184E                          1076  WORD2BUFFER:
0000184E                          1077              *MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
0000184E                          1078              *MOVE.B      #'$', (A2)+  
0000184E  4284                    1079              CLR.L       D4                  *clear counter
00001850  2E88                    1080              MOVE.L      A0, (A7)
00001852  2E17                    1081              MOVE.L      (A7), D7
00001854  2417                    1082              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
00001856  183C 0004               1083              MOVE.B      #4, D4              *load counter
0000185A                          1084  
0000185A                          1085  w2bLoop                 
0000185A  B83C 0000               1086              CMP.B       #$00, D4            *compare counter with 0
0000185E  6700 0014               1087              BEQ         endw2b              *if zero, return
00001862  E95A                    1088              ROL.W       #4, D2              *roll the bits in D2 to the left
00001864  3602                    1089              MOVE.W      D2, D3              *move rolled bits into temp storage
00001866  0243 000F               1090              ANDI.W      #$000F, D3          *and the bits to isolate ascii char   
0000186A  4EB8 17AE               1091              JSR         HEX2ASCII           *load ascii char into buffer            
0000186E  5304                    1092              SUBQ.B      #$1, D4             *subtract from counter
00001870  4EF8 185A               1093              JMP         w2bLoop             *keep looping until counter hits zero
00001874                          1094              
00001874  3607                    1095  endw2b      MOVE.W      D7, D3              *re-load current word for temp storage            
00001876  5448                    1096              ADDQ.W      #2, A0              *advancing memory pointer by word  
00001878                          1097              *MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
00001878  4E75                    1098              RTS                             *return
0000187A                          1099  *===========================================================
0000187A                          1100   
0000187A                          1101  ************************************************************
0000187A                          1102  *LONG2BUFFER
0000187A                          1103  *Buffer: $XXXXXXXX
0000187A                          1104  ************************************************************           
0000187A                          1105  LONG2BUFFER:
0000187A  48E7 FE00               1106              MOVEM.L     D0-D6,-(SP)         *save data registers to the stack
0000187E                          1107              *MOVE.B      #'$', (A2)+  
0000187E  4284                    1108              CLR.L       D4                  *clear counter
00001880  2E88                    1109              MOVE.L      A0, (A7)
00001882  2E17                    1110              MOVE.L      (A7), D7
00001884  2417                    1111              MOVE.L      (A7), D2            *move current word into D2 for rolling purposes
00001886  183C 0008               1112              MOVE.B      #8, D4              *load counter
0000188A                          1113  
0000188A                          1114  l2bLoop                 
0000188A  B83C 0000               1115              CMP.B       #$00, D4            *compare counter with 0
0000188E  6700 0014               1116              BEQ         endl2b              *if 0, return
00001892  E95A                    1117              ROL.W       #4, D2              *
00001894  3602                    1118              MOVE.W      D2, D3              *
00001896  0243 000F               1119              ANDI.W      #$000F, D3          *isolate
0000189A  4EB8 17AE               1120              JSR         HEX2ASCII           *to buffer           
0000189E  5304                    1121              SUBQ.B      #$1, D4             *subtract from counter
000018A0  4EF8 188A               1122              JMP         l2bLoop             *loop
000018A4                          1123              
000018A4  3607                    1124  endl2b      MOVE.W      D7, D3              *load from utility           
000018A6  5848                    1125              ADDQ.W      #4, A0              *advancing memory pointer by word  
000018A8  4CDF 007F               1126              MOVEM.L     (SP)+,D0-D6         *load data registers from stack   
000018AC  4E75                    1127              RTS  
000018AE                          1128  *===========================================================
000018AE                          1129  
000018AE                          1130             
000018AE                          1131  ************************************************************
000018AE                          1132  *IMM2BUFER
000018AE                          1133  *Description: Converts immediate data and sends to buffer
000018AE                          1134  ************************************************************ 
000018AE                          1135  IMM2BUFER:
000018AE  14FC 0023               1136              MOVE.B  #$23, (A2)+     *'#' to buffer
000018B2  4EB8 177C               1137              JSR     srSize          *get bit size
000018B6  0C03 0001               1138              CMPI.B  #%01, D3        *byte?
000018BA  6700 FF5E               1139              BEQ     BYTE2BUFFER     *
000018BE  0C03 0003               1140              CMPI.B  #%11, D3        *word?
000018C2  678A                    1141              BEQ     WORD2BUFFER     *
000018C4  0C03 0002               1142              CMPI.B  #%10, D3        *long?
000018C8  67B0                    1143              BEQ     LONG2BUFFER     *
000018CA  4E75                    1144  endI2B      RTS                     *return
000018CC                          1145  *===========================================================        
000018CC                          1146  
000018CC                          1147  ************************************************************
000018CC                          1148  *BADINST
000018CC                          1149  *Description: A bad instruction has been called, print to console
000018CC                          1150  *Registers Used:
000018CC                          1151  *D5 - flag condition
000018CC                          1152  *A2 - buffer address of decoded instruction
000018CC                          1153  *A2 - working address    
000018CC                          1154  
000018CC                          1155  
000018CC                          1156  
000018CC                          1157  ************************************************************
000018CC                          1158  BADINST:
000018CC  45F9 00009000           1159              LEA     buf, A2
000018D2  4EB8 11E8               1160              JSR     ADDRESS
000018D6                          1161              
000018D6  14FC 0042               1162              MOVE.B  #$42,(A2)+      *'B' to buffer
000018DA  14FC 0041               1163              MOVE.B  #$41,(A2)+      *'A' to buffer
000018DE  14FC 0044               1164              MOVE.B  #$44,(A2)+      *'D' to buffer
000018E2  14FC 0020               1165              MOVE.B  #$20,(A2)+      *' ' to buffer
000018E6  14FC 0049               1166              MOVE.B  #$49,(A2)+      *'I' to buffer
000018EA  14FC 004E               1167              MOVE.B  #$4E,(A2)+      *'N' to buffer
000018EE  14FC 0053               1168              MOVE.B  #$53,(A2)+      *'S' to buffer
000018F2  14FC 0054               1169              MOVE.B  #$54,(A2)+      *'T' to buffer
000018F6  14FC 0052               1170              MOVE.B  #$52,(A2)+      *'R' to buffer
000018FA  14FC 0055               1171              MOVE.B  #$55,(A2)+      *'U' to buffer
000018FE  14FC 0043               1172              MOVE.B  #$43,(A2)+      *'C' to buffer
00001902  14FC 0054               1173              MOVE.B  #$54,(A2)+      *'T' to buffer
00001906  14FC 0049               1174              MOVE.B  #$49,(A2)+      *'I' to buffer
0000190A  14FC 004E               1175              MOVE.B  #$4E,(A2)+      *'N' to buffer
0000190E  4EF8 124E               1176  endbadinst  JMP     endgop                           *return
00001912                          1177  *===========================================================
00001912                          1178  
00001912                          1179  CLEARBUFFER:
00001912  47F9 00009000           1180              LEA     buf, A3
00001918  4DF9 00001FF4           1181              LEA     bufferend, A6
0000191E  4293                    1182  clearloop   CLR.L   (A3)
00001920  584B                    1183              ADDQ.W  #4, A3
00001922  BDCB                    1184              CMPA.L  A3, A6
00001924  6CF8                    1185              BGE     clearloop
00001926  4E75                    1186              RTS
00001928                          1187              
00001928                          1188              
00001928                          1189  
00001928                          1190  ************************************************************
00001928                          1191  *  _____ _   _ ____      ____ ___ __  __ 
00001928                          1192  * | ____| \ | |  _ \    / ___|_ _|  \/  |
00001928                          1193  * |  _| |  \| | | | |   \___ \| || |\/| |
00001928                          1194  * | |___| |\  | |_| |    ___) | || |  | |
00001928                          1195  * |_____|_| \_|____/    |____/___|_|  |_|
00001928                          1196  *                                       
00001928                          1197  *END
00001928                          1198  *Description: Ends program
00001928                          1199  ************************************************************          
00001928                          1200  END:
00001928  FFFF FFFF               1201              SIMHALT              
0000192C                          1202  *===========================================================
0000192C                          1203           
0000192C                          1204  *-----------------------------------------------------------
0000192C                          1205  *variables
0000192C                          1206  *-----------------------------------------------------------
0000192C= 20 20 20 20 20 20 ...   1207  intro       dc.b '          66666666        888888888     KKKKKKKKK    KKKKKKK',CR,LF 
0000196A= 20 20 20 20 20 20 ...   1208              dc.b '         6::::::6       88:::::::::88   K:::::::K    K:::::K',CR,LF
000019A8= 20 20 20 20 20 20 ...   1209              dc.b '        6::::::6      88:::::::::::::88 K:::::::K    K:::::K',CR,LF
000019E6= 20 20 20 20 20 20 ...   1210              dc.b '       6::::::6      8::::::88888::::::8K:::::::K   K::::::K',CR,LF
00001A24= 20 20 20 20 20 20 ...   1211              dc.b '      6::::::6       8:::::8     8:::::8KK::::::K  K:::::KKK',CR,LF
00001A62= 20 20 20 20 20 36 ...   1212              dc.b '     6::::::6        8:::::8     8:::::8  K:::::K K:::::K   ',CR,LF
00001AA0= 20 20 20 20 36 3A ...   1213              dc.b '    6::::::6          8:::::88888:::::8   K::::::K:::::K    ',CR,LF
00001ADE= 20 20 20 36 3A 3A ...   1214              dc.b '   6::::::::66666      8:::::::::::::8    K:::::::::::K     ',CR,LF
00001B1C= 20 20 36 3A 3A 3A ...   1215              dc.b '  6::::::::::::::66   8:::::88888:::::8   K:::::::::::K     ',CR,LF
00001B5A= 20 20 36 3A 3A 3A ...   1216              dc.b '  6::::::66666:::::6 8:::::8     8:::::8  K::::::K:::::K    ',CR,LF
00001B98= 20 20 36 3A 3A 3A ...   1217              dc.b '  6:::::6     6:::::68:::::8     8:::::8  K:::::K K:::::K   ',CR,LF    
00001BD6= 20 20 36 3A 3A 3A ...   1218              dc.b '  6:::::6     6:::::68:::::8     8:::::8KK::::::K  K:::::KKK',CR,LF     
00001C14= 20 20 36 3A 3A 3A ...   1219              dc.b '  6::::::66666::::::68::::::88888::::::8K:::::::K   K::::::K',CR,LF     
00001C52= 20 20 20 36 36 3A ...   1220              dc.b '   66:::::::::::::66  88:::::::::::::88 K:::::::K    K:::::K',CR,LF
00001C90= 20 20 20 20 20 36 ...   1221              dc.b '     66:::::::::66      88:::::::::88   K:::::::K    K:::::K',CR,LF
00001CCE= 20 20 20 20 20 20 ...   1222              dc.b '       666666666          888888888     KKKKKKKKK    KKKKKKK',CR,LF
00001D0C= 20 20 20 20 20 20 ...   1223              dc.b '                                                            ',CR,LF  
00001D4A= 20 20 20 20 20 20 ...   1224              dc.b '                                                            ',CR,LF  
00001D88= 20 20 20 20 5F 5F ...   1225              dc.b '    ____  _                                __    __         ',CR,LF
00001DC6= 20 20 20 2F 20 5F ...   1226              dc.b '   / __ \(_)________ _________  ____ ___  / /_  / /__  _____',CR,LF
00001E04= 20 20 2F 20 2F 20 ...   1227              dc.b '  / / / / / ___/ __ `/ ___/ _ \/ __ `__ \/ __ \/ / _ \/ ___/',CR,LF
00001E42= 20 2F 20 2F 5F 2F ...   1228              dc.b ' / /_/ / (__  ) /_/ (__  )  __/ / / / / / /_/ / /  __/ /    ',CR,LF
00001E80= 2F 5F 5F 5F 5F 5F ...   1229              dc.b '/_____/_/____/\__,_/____/\___/_/ /_/ /_/_.___/_/\___/_/     ',CR,LF
00001EBE= 20 20 20 20 20 20 ...   1230              dc.b '                                                            ',CR,LF  
00001EFC= 20 20 20 20 20 20 ...   1231              dc.b '                                                            ',0,CR,LF 
00001F3B                          1232              
00001F3C= 0610                    1233  i_length    dc.w    i_length-intro
00001F3E                          1234  
00001F3E= 45 6E 74 65 72 20 ...   1235  srt_addr    dc.b    'Enter starting address: $',0
00001F58= 001A                    1236  s_len       dc.w    s_len-srt_addr
00001F5A                          1237  
00001F5A= 45 6E 74 65 72 20 ...   1238  end_addr    dc.b    'Enter ending address: $',0
00001F72= 0018                    1239  e_len       dc.w    e_len-end_addr
00001F74                          1240  
00001F74= 54 68 65 20 73 74 ...   1241  t_str_start dc.b    'The start address is: $',0
00001F8C= 0018                    1242  t_start     dc.w    t_start-t_str_start
00001F8E                          1243  
00001F8E= 54 68 65 20 65 6E ...   1244  t_str_end   dc.b    'The end address is: $',0
00001FA4= 0016                    1245  t_end       dc.w    t_end-t_str_end
00001FA6                          1246  
00001FA6= 45 72 72 6F 72 3A ...   1247  str_error   dc.b    'Error: starting or ending address has error',0
00001FD2= 002C                    1248  err_len     dc.w    err_len-str_error 
00001FD4                          1249  
00001FD4= 50 72 65 73 73 20 ...   1250  str_cont    dc.b    'Press enter to continue.',0
00001FEE= 001A                    1251  cont_len    dc.w    cont_len-str_cont
00001FF0                          1252  
00001FF0= 00                      1253  str_cr      dc.b    '',0
00001FF2= 0002                    1254  cr_len      dc.w    cr_len-str_cr
00001FF4                          1255  
00001FF4                          1256  *buffer      dc.l    1
00001FF4= 01                      1257  bufferend   dc.b    1
00001FF5                          1258  print_stack ds.b    8
00001FFD                          1259  
00001FFE                          1260  v_srt_add   ds.l    1               *store start address
00002002                          1261  v_end_add   ds.l    1               *store end address
00002006                          1262  v_test      ds.l    1               *start a temp value
0000200A                          1263  
0000200A                          1264  
0000200A                          1265      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESS             11E8
ADDRFILL            1208
ADDRLOOP            120E
ASCII2HEX           1128
B2BLOOP             182A
BADFLAG             0
BADINST             18CC
BUF                 9000
BUFFEREND           1FF4
BUFFER_PREP         11C4
BYTE2BUFFER         181A
CLEAR               10A6
CLEARBUFFER         1912
CLEARLOOP           191E
CODE0010_CONT       1312
CODE0010_CONT2      1318
CODE0011_CONT       1352
CODE0011_CONT2      1358
CONT_LEN            1FEE
CR                  D
CR_LEN              1FF2
DIS_BADINPUT        1058
DIS_CONT            1086
DIS_CR              1072
DIS_INTRO_MSG       1044
EACODE000           1686
EACODE001           1698
EACODE010           16AA
EACODE011           16C4
EACODE100           16E2
EACODE101           1700
EACODE110           1708
EACODE111           1710
EA_TABLE            1656
END                 1928
ENDA2H              11B8
ENDADDR             122C
ENDB2B              1844
ENDBADINST          190E
ENDBF               122E
ENDBI               106E
ENDBP               11E6
ENDCLEAR            10B6
ENDDC               10A4
ENDEA000            1696
ENDEA001            16A8
ENDEA010            16C2
ENDEA011            16E0
ENDEA100            16FE
ENDEA101            1706
ENDEA110            170E
ENDEA111            173A
ENDGD               1756
ENDGOP              124E
ENDGS               174C
ENDH2A              17C4
ENDI2B              18CA
ENDINPUT            1126
ENDINTRO            1056
ENDL2B              18A4
ENDOP0000           12B6
ENDOP0001           12EE
ENDOP0010           132E
ENDOP0100           1376
ENDOP0101           137E
ENDOP0110           1386
ENDOP0111           138E
ENDOP1000           1396
ENDOP1001           1440
ENDOP1010           1448
ENDOP1011           14E4
ENDOP1100           1570
ENDOP1101           1626
ENDOP111            1636
ENDOP1110           162E
ENDR2B              17D6
ENDRB               1742
ENDS2B              1818
ENDSR               17AC
ENDSWAP             177A
ENDW2B              1874
END_ADDR            1F5A
END_CR              1084
ERROR               1196
ERR_LEN             1FD2
E_LEN               1F72
GETDIRECTION        174E
GETEA               1638
GETOPCODE           1230
GETREGISTER         173C
GETSIZE             1744
GOODFLAG            1
HEX2ASCII           17AE
IMM2BUFER           18AE
INTRO               192C
I_LENGTH            1F3C
L2BLOOP             188A
LENGTH              0
LETTER              17BE
LF                  A
LONG2BUFFER         187A
LOOP                1138
LOWER2HEX           118A
MAIN                1004
MAIN_CONT           1036
MAIN_END            1040
MAIN_INPUT          1016
MAIN_LOOP           1022
MAXADD              FFFFFF
MINADD              0
NUM2HEX             1172
NUMBER              17B6
OPADD               15D8
OPADDA              15B2
OPADDD01            1612
OPADDL              15AE
OPANDD01            155C
OPCMP               1496
OPCMPA              1458
OPCODE0000          12B0
OPCODE0001          12B8
OPCODE0010          12F0
OPCODE0011          1330
OPCODE0100          1370
OPCODE0101          1378
OPCODE0110          1380
OPCODE0111          1388
OPCODE1000          1390
OPCODE1001          1398
OPCODE1010          1442
OPCODE1011          144A
OPCODE1100          14E6
OPCODE1101          1572
OPCODE1110          1628
OPCODE1111          1630
OPEOR               14DE
OPSUBL              13D0
OPSUBSUB            13F6
OPSUBSUBA           13D4
OPSUBSUBR           142C
OP_TABLE            1250
PRINTCOUNT          A
PRINT_STACK         1FF5
REG2BUFFER          17C6
RESUME              11A0
S2BB                1800
S2BL                1814
S2BW                180A
SIZE2BUFFER         17D8
SRL                 17A8
SRSIZE              177C
SRT_ADDR            1F3E
SRW                 179E
STACK               A000
START               1000
STR_CONT            1FD4
STR_CR              1FF0
STR_ERROR           1FA6
SWAPREG             1758
S_LEN               1F58
TASK0               0
TASK1               1
TASK13              D
TASK14              E
TASK2               2
TASK3               3
T_END               1FA4
T_START             1F8C
T_STR_END           1F8E
T_STR_START         1F74
UPPER2HEX           117E
U_INPUT             10B8
V_END_ADD           2002
V_SRT_ADD           1FFE
V_TEST              2006
W2B                 17C2
W2BLOOP             185A
WORD2BUFFER         184E
