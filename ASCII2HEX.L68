00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 05/30/20 10:16:17 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Scott Shirley
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7  *Register Use
00000000                             8  *For consistency, please utilize registers in the following way.
00000000                             9  *
00000000                            10  *D0 -
00000000                            11  *D1 -
00000000                            12  *D2 - copy of working address
00000000                            13  *D3 - utility register
00000000                            14  *D4 -
00000000                            15  *D5 - flag condition
00000000                            16  *D6 - counter
00000000                            17  *D7 -
00000000                            18  *
00000000                            19  *A0 - temp address holder
00000000                            20  *A1 - trap address
00000000                            21  *A2 - buffer address of decoded instruction
00000000                            22  *A3 -
00000000                            23  *A4 - starting address
00000000                            24  *A5 - ending address
00000000                            25  *A6 -
00000000                            26  *A7 -
00000000                            27  *-----------------------------------------------------------
00000000                            28  
00000000                            29   
00000000                            30   
00000000                            31  * Variables and EQUs
00000000  =00001000                 32  start       EQU     $1000               *start address
00000000  =0000A000                 33  stack       EQU     $A000               *stack address  
00000000                            34   
00000000                            35  
00000000  =00000000                 36  minAdd      EQU     $00000000           *start of address space
00000000  =00FFFFFF                 37  maxAdd      EQU     $00FFFFFF           *end of address space
00000000                            38  
00000000  =0000000D                 39  CR          EQU     $0D                 *carriage return
00000000  =0000000A                 40  LF          EQU     $0A                 *line feed
00000000                            41  
00000000  =00000001                 42  goodflag    EQU     1                   *good flag condition
00000000  =00000000                 43  badflag     EQU     0                   *bad flag condition
00000000  =00000000                 44  length      EQU     0                   *
00000000                            45  
00000000  =0000000A                 46  printCount  EQU     10                  *number of lines printed to console before user input
00000000                            47  
00000000                            48  *TRAP tasks for preload
00000000  =00000000                 49  task0       EQU     00                  *Display string at (A1), D1.W bytes long (max 255) with carriage return and line feed (CR, LF)
00000000  =00000001                 50  task1       EQU     01                  *Display string at (A1), D1.W bytes long (max 255) without CR, LF
00000000  =00000002                 51  task2       EQU     02                  *Read string from keyboard and store at (A1), NULL terminated, length retuned in D1.W (max 80)
00000000  =00000003                 52  task3       EQU     03                  *Display signed number in D1.L in decimal in smallest field
00000000  =0000000D                 53  task13      EQU     13                  *Display the NULL terminated string at (A1) with CR, LF
00000000  =0000000E                 54  task14      EQU     14                  *Display the NULL terminated string at (A1) without CR, LF
00000000                            55  *-----------------------------------------------------------
00000000                            56  *beging program
00000000                            57  *-----------------------------------------------------------
00001000                            58              ORG     start
00001000  6100 0092                 59              BSR     intro_msg           *print intro message
00001004  6100 00BC                 60  main        BSR     CLEAR               *clear all registers
00001008  4FF9 0000A000             61              LEA     stack, SP           *load stack pointer
0000100E  45F9 000012D5             62              LEA     buffer, A2          *set buffer for input
00001014  2C4A                      63              MOVEA.L A2,A6 
00001016                            64              
00001016                            65              
00001016  6100 00BC                 66  main_input  BSR     U_INPUT             *
0000101A  BA3C 0000                 67              CMP.B   #$0, D5             *
0000101E  6700 0088                 68              BEQ     badInput            *bad flag, reinput 
00001022                            69              
00001022                            70              
00001022  4EB9 000011E0             71  main_loop   JSR     bufferPrep          *prep buffer
00001028                            72      
00001028  103C 000E                 73              MOVE.B  #task14, D0         *
0000102C  43F9 00001258             74              LEA     t_str_start, A1     *print start add test message     
00001032  4E4F                      75              TRAP    #15                 *
00001034                            76              
00001034  2239 000012D6             77              MOVE.L  v_srt_add, D1       *
0000103A  103C 0003                 78              MOVE.B  #task3, D0          *print start add test value
0000103E  4E4F                      79              TRAP    #15                 *
00001040                            80              
00001040  103C 000D                 81              MOVE.B  #task13, D0         *print carriage rturn
00001044  43F9 000012D4             82              LEA     str_cr, A1          *
0000104A  4E4F                      83              TRAP    #15                 *
0000104C                            84         
0000104C  103C 000E                 85              MOVE.B  #task14, D0         *print end add test message
00001050  43F9 00001272             86              LEA     t_str_end, A1         *    
00001056  4E4F                      87              TRAP    #15                 *
00001058                            88    
00001058  2239 000012DA             89              MOVE.L  v_end_add, D1       *
0000105E  103C 0003                 90              MOVE.B  #task3, D0          *print end add test value
00001062  4E4F                      91              TRAP    #15                 *
00001064                            92                   
00001064                            93  
00001064                            94  *loop checking      
00001064  BBC8                      95              CMPA.L  A0, A5              * have we reached the end of our address range?
00001066  6F00 0028                 96              BLE     main_end  
0000106A                            97   
0000106A  5246                      98              ADDI    #1, D6              *add counter
0000106C  BC7C 000A                 99              CMP     #printcount, D6     *check loop progress
00001070  66B0                     100              BNE     main_loop
00001072                           101                
00001072                           102              
00001072                           103  
00001072  103C 0001                104  main_cont   MOVE.B  #task1, D0
00001076  43F9 000012B8            105              LEA     str_cont, A1
0000107C  3239 000012D2            106              MOVE.W  cont_len, D1
00001082  4E4F                     107              TRAP    #15
00001084                           108              
00001084  103C 0002                109              MOVE.B  #task2,D0
00001088  4E4F                     110              TRAP    #15
0000108A  4246                     111              CLR     D6                  *clear counter, reset loop
0000108C  4EF8 1022                112              JMP     main_loop
00001090                           113  
00001090                           114  
00001090                           115  
00001090  6100 0172                116  main_end    BSR     END
00001094                           117  
00001094                           118  *-----------------------------------------------------------
00001094                           119  *subroutines
00001094                           120  *-----------------------------------------------------------
00001094                           121  *intro message display
00001094                           122  intro_msg
00001094  103C 000D                123              MOVE.B  #13,D0
00001098  43F9 00001208            124              LEA     intro,A1
0000109E  3239 00001220            125              MOVE.W  i_length,D1
000010A4  4E4F                     126              TRAP    #15
000010A6  4E75                     127  endIntro    RTS
000010A8                           128  
000010A8                           129  *bad input error message display
000010A8                           130  badInput
000010A8  103C 0000                131              MOVE.B  #task0,D0
000010AC  43F9 0000128A            132              LEA     str_error, A1
000010B2  3239 000012B6            133              MOVE.W  err_len, D1
000010B8  4E4F                     134              TRAP    #15
000010BA  1A3C 0000                135              MOVE.B  #badFlag,D5
000010BE  4EB8 1004                136  endBI       JSR     main
000010C2                           137            
000010C2                           138  *clear all registers         
000010C2                           139  CLEAR:
000010C2  4240                     140              CLR     D0
000010C4  4241                     141              CLR     D1
000010C6  4242                     142              CLR     D2
000010C8  4243                     143              CLR     D3
000010CA  4244                     144              CLR     D4
000010CC  4245                     145              CLR     D5
000010CE  4246                     146              CLR     D6
000010D0  4247                     147              CLR     D7
000010D2  4E75                     148  endClear    RTS
000010D4                           149  
000010D4                           150  ************************************************************
000010D4                           151  *address input
000010D4                           152  ************************************************************
000010D4                           153  U_INPUT:
000010D4  103C 0001                154              MOVE.B  #task1,D0           *
000010D8  43F9 00001222            155              LEA     srt_addr,A1         *
000010DE  3239 0000123C            156              MOVE.W  s_len,D1            *
000010E4  4E4F                     157              TRAP    #15                 *
000010E6  D3FC 0000123C            158              ADDA.L  #s_len,A1           *
000010EC  103C 0002                159              MOVE.B  #task2,D0           *
000010F0  4E4F                     160              TRAP    #15                 *
000010F2  4EB9 00001144            161              JSR     ASCII2HEX
000010F8  BA3C 0000                162              CMP.B   #$00,D5             *bad input?
000010FC  6700 0044                163              BEQ     endInput
00001100  23C7 000012D6            164              MOVE.L  D7, v_srt_add       *store to varable
00001106  4247                     165              CLR     D7
00001108                           166              
00001108  2848                     167              MOVEA.L A0,A4       
0000110A  103C 0001                168              MOVE.B  #task1,D0
0000110E  43F9 0000123E            169              LEA     end_addr,A1
00001114  3239 00001256            170              MOVE.W  e_len,D1         
0000111A  4E4F                     171              TRAP    #15         
0000111C  D3FC 00001256            172              ADDA.L  #e_len,A1
00001122  103C 0002                173              MOVE.B  #task2,D0
00001126  4E4F                     174              TRAP    #15
00001128  4EB9 00001144            175              JSR     ASCII2HEX
0000112E  BA3C 0000                176              CMP.B   #$00,D5             *bad input?
00001132  6700 000E                177              BEQ     endInput
00001136  23C7 000012DA            178              MOVE.L  D7, v_end_add        *store to varable
0000113C  4247                     179              CLR     D7
0000113E                           180             
0000113E                           181             **********swap************
0000113E                           182  
0000113E  2A48                     183              MOVEA.L A0,A5               *store ending to 
00001140                           184  A5
00001140                           185              *MOVEA.L A0,A4               *copy ending to A4
00001140  204C                     186              MOVEA.L A4,A0               *store starting in A0                    
00001142  4E75                     187  endInput    RTS
00001144                           188  
00001144                           189  ************************************************************
00001144                           190  *ascii2hex - see flowchart for logic
00001144                           191  *D3 - Placeholder for current ascii byte
00001144                           192  *D4 - Translated address
00001144                           193  *D5 - Return status
00001144                           194  *D6 - Counter (6)
00001144                           195  *A0 - Stored address at end of subroutine
00001144                           196  
00001144                           197  ************************************************************
00001144                           198  ASCII2HEX:
00001144                           199              
00001144  48E7 F800                200              MOVEM.L D0-D4,-(SP)         *save data registers to the stack
00001148  4EB8 10C2                201              JSR     CLEAR
0000114C  1A3C 0001                202              MOVE.B  #$01,D5             *preset flag condition to good
00001150  3C3C 0000                203              MOVE    #length,D6
00001154                           204  
00001154                           205  loop
00001154  1619                     206              MOVE.B  (A1)+,D3            *
00001156  B63C 0030                207              CMP.B   #$30,D3             *byte < 30??
0000115A  6D00 0056                208              BLT     error               *
0000115E                           209              
0000115E  B63C 003A                210              CMP.B   #$3A,D3             *byte < 3A??
00001162  6D00 002A                211              BLT     num2hex             *
00001166                           212              
00001166  B63C 0041                213              CMP.B   #$41,D3             *byte < 41??
0000116A  6D00 0046                214              BLT     error               *
0000116E                           215              
0000116E  B63C 0047                216              CMP.B   #$47,D3             *byte < 47?
00001172  6D00 0026                217              BLT     upper2hex           *
00001176                           218              
00001176  B63C 0061                219              CMP.B   #$61,D3             *byte < 61??
0000117A  6D00 0036                220              BLT     error               *
0000117E                           221              
0000117E  B63C 0067                222              CMP.B   #$67,D3             *byte < 67??
00001182  6D00 0022                223              BLT     lower2hex           *
00001186                           224              
00001186  B63C 0066                225              CMP.B   #$66,D3             *byte > 66??
0000118A  6E00 0026                226              BGT     error               *
0000118E                           227  
0000118E                           228  num2hex
0000118E  0403 0030                229              SUBI.B  #$30,D3             *subracthex value of 0 to get correct value of input
00001192  D803                     230              ADD.B   D3,D4               *
00001194  4EF9 000011BC            231              JMP     resume              *return to top
0000119A                           232              
0000119A                           233  upper2hex
0000119A  0403 0037                234              SUBI.B  #$37,D3             *subracthex value of A to get correct value of input
0000119E  D803                     235              ADD.B   D3,D4               *
000011A0  4EF9 000011BC            236              JMP     resume              *return to top
000011A6                           237              
000011A6                           238  lower2hex
000011A6  0403 0057                239              SUBI.B  #$57,D3             *subracthex value of a to get correct value of input
000011AA  D803                     240              ADD.B   D3,D4               *
000011AC  4EF9 000011BC            241              JMP     resume              *return to top
000011B2                           242  error
000011B2  1A3C 0000                243              MOVE.B  #$00,D5             *flag as bad input and return
000011B6  4EF9 000011D4            244              JMP     endA2H              *return to top
000011BC                           245  resume
000011BC  5246                     246              ADD     #1,D6               *increment length counter
000011BE  BC7C 0006                247              CMP     #6,D6               *check if done
000011C2  6700 0010                248              BEQ     endA2H              *
000011C6  0C11 0000                249              CMP.B   #$00,(A1)           *end of string??
000011CA  6700 0008                250              BEQ     endA2H              *
000011CE  E984                     251              ASL.L   #4,D4               *shiftleft by 4 bits to get next value            
000011D0  4EF8 1154                252              JMP     loop                *return to top
000011D4                           253  
000011D4                           254  endA2H
000011D4  2044                     255              MOVE.L  D4,A0               *
000011D6  2E04                     256              MOVE.L  D4,D7               *move address to temp register
000011D8  4246                     257              CLR     D6                  *clear counter
000011DA  4CDF 001F                258              MOVEM.L (SP)+,D0-D4         *load data registers from stack      
000011DE  4E75                     259              RTS                         *
000011E0                           260  
000011E0                           261  
000011E0                           262  
000011E0                           263  
000011E0                           264  ************************************************************
000011E0                           265  *printbuffer
000011E0                           266  ************************************************************
000011E0  2458                     267  bufferPrep  MOVEA.L (A0)+, A2
000011E2                           268  
000011E2  4E75                     269  endBP       RTS
000011E4                           270  
000011E4                           271  
000011E4                           272  printinst   
000011E4  103C 000E                273              MOVE.B  #14, D0
000011E8                           274              *MOVE.W  #12,D1
000011E8  4E4F                     275              TRAP    #15
000011EA  4E75                     276              RTS
000011EC                           277              
000011EC                           278  ************************************************************
000011EC                           279  *Hex2ASCII 
000011EC                           280  ************************************************************
000011EC  BC3C 000A                281  Hex2ASCII   CMP.B   #$A,D6              * Confirm hex character?
000011F0  6C00 000A                282              BGE     letter              * Is it a letter or number?
000011F4  0606 0030                283              ADDI.B  #$30,D6             * Convert decimal to ASCII
000011F8  6000 0006                284              BRA     write2Buff          * save to good buffer
000011FC  0606 0037                285  letter      ADDI.B  #$37,D6
00001200  14C6                     286  write2Buff  MOVE.B  D6,(A2)+
00001202  4E75                     287              RTS           
00001204                           288              
00001204                           289  END:
00001204  FFFF FFFF                290              SIMHALT             ; halt simulator            
00001208                           291  *-----------------------------------------------------------
00001208                           292  *variables
00001208                           293  *-----------------------------------------------------------
00001208= 45 61 73 79 36 38 ...    294  intro       dc.b    'Easy68k Disassembler',0,CR,LF
00001220= 0018                     295  i_length    dc.w    i_length-intro
00001222                           296  
00001222= 45 6E 74 65 72 20 ...    297  srt_addr    dc.b    'Enter starting address: $',0
0000123C= 001A                     298  s_len       dc.w    s_len-srt_addr
0000123E                           299  
0000123E= 45 6E 74 65 72 20 ...    300  end_addr    dc.b    'Enter ending address: $',0
00001256= 0018                     301  e_len       dc.w    e_len-end_addr
00001258                           302  
00001258= 54 68 65 20 73 74 ...    303  t_str_start dc.b    'The start address is: $',0
00001270= 0018                     304  t_start     dc.w    t_start-t_str_start
00001272                           305  
00001272= 54 68 65 20 65 6E ...    306  t_str_end   dc.b    'The end address is: $',0
00001288= 0016                     307  t_end       dc.w    t_end-t_str_end
0000128A                           308  
0000128A= 45 72 72 6F 72 3A ...    309  str_error   dc.b    'Error: starting or ending address has error',0
000012B6= 002C                     310  err_len     dc.w    err_len-str_error 
000012B8                           311  
000012B8= 50 72 65 73 73 20 ...    312  str_cont    dc.b    'Press enter to continue.',0
000012D2= 001A                     313  cont_len    dc.w    cont_len-str_cont
000012D4                           314  
000012D4= 00                       315  str_cr      dc.b    '',0
000012D5                           316  
000012D5= 01                       317  buffer      dc.b    1
000012D6                           318  
000012D6                           319  v_srt_add   ds.l    1               *store start address
000012DA                           320  V_end_add   ds.l    1               *store end address
000012DE                           321  
000012DE                           322  
000012DE                           323      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A5                  1140
ASCII2HEX           1144
BADFLAG             0
BADINPUT            10A8
BUFFER              12D5
BUFFERPREP          11E0
CLEAR               10C2
CONT_LEN            12D2
CR                  D
END                 1204
ENDA2H              11D4
ENDBI               10BE
ENDBP               11E2
ENDCLEAR            10D2
ENDINPUT            1142
ENDINTRO            10A6
END_ADDR            123E
ERROR               11B2
ERR_LEN             12B6
E_LEN               1256
GOODFLAG            1
HEX2ASCII           11EC
INTRO               1208
INTRO_MSG           1094
I_LENGTH            1220
LENGTH              0
LETTER              11FC
LF                  A
LOOP                1154
LOWER2HEX           11A6
MAIN                1004
MAIN_CONT           1072
MAIN_END            1090
MAIN_INPUT          1016
MAIN_LOOP           1022
MAXADD              FFFFFF
MINADD              0
NUM2HEX             118E
PRINTCOUNT          A
PRINTINST           11E4
RESUME              11BC
SRT_ADDR            1222
STACK               A000
START               1000
STR_CONT            12B8
STR_CR              12D4
STR_ERROR           128A
S_LEN               123C
TASK0               0
TASK1               1
TASK13              D
TASK14              E
TASK2               2
TASK3               3
T_END               1288
T_START             1270
T_STR_END           1272
T_STR_START         1258
UPPER2HEX           119A
U_INPUT             10D4
V_END_ADD           12DA
V_SRT_ADD           12D6
WRITE2BUFF          1200
